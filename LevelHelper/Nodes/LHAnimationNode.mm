//  This file was generated by LevelHelper
//  http://www.levelhelper.org
//
//  LevelHelperLoader.mm
//  Created by Bogdan Vladu
//  Copyright 2011 Bogdan Vladu. All rights reserved.
////////////////////////////////////////////////////////////////////////////////
//
//  This software is provided 'as-is', without any express or implied
//  warranty.  In no event will the authors be held liable for any damages
//  arising from the use of this software.
//  Permission is granted to anyone to use this software for any purpose,
//  including commercial applications, and to alter it and redistribute it
//  freely, subject to the following restrictions:
//  The origin of this software must not be misrepresented; you must not
//  claim that you wrote the original software. If you use this software
//  in a product, an acknowledgment in the product documentation would be
//  appreciated but is not required.
//  Altered source versions must be plainly marked as such, and must not be
//  misrepresented as being the original software.
//  This notice may not be removed or altered from any source distribution.
//  By "software" the author refers to this code file and not the application 
//  that was used to generate this file.
//
////////////////////////////////////////////////////////////////////////////////
#import "LHAnimationNode.h"
#import "LevelHelperLoader.h"
#import "LHSettings.h"
#import "LHDictionaryExt.h"
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

@interface LHAnimationFrameInfo : NSObject
{
    float   delayPerUnit;
    CGPoint offset;
    NSDictionary* notifications;
    NSString* spriteframeName;
    CGRect rect;
    bool rectIsRotated;
    CGPoint spriteFrameOffset;
    CGSize spriteFrameSize;
}

@property float delayPerUnit;
@property CGPoint offset;
@property (readonly) NSDictionary* notifications;
@property (readonly) NSString* spriteframeName;
@property (readonly) CGRect rect;
@property (readonly) bool rectIsRotated;
@property (readonly) CGPoint spriteFrameOffset;
@property (readonly) CGSize spriteFrameSize;

+(id)frameWithDictionary:(NSDictionary*)dictionary sprite:(LHSprite*)sprite;
@end

@implementation LHAnimationFrameInfo
@synthesize delayPerUnit;
@synthesize offset;
@synthesize notifications;
@synthesize spriteframeName;
@synthesize rect;
@synthesize rectIsRotated;
@synthesize spriteFrameOffset;
@synthesize spriteFrameSize;

-(void)dealloc{
    
  //  NSLog(@"LHSpriteFrame Dealloc %@", spriteframeName);
    
#ifndef LH_ARC_ENABLED
    [notifications release];
    [spriteframeName release];
	[super dealloc];
#endif
}
-(id)initWithDictionary:(NSDictionary*)dictionary sprite:(LHSprite*)sprite
{
    self = [super init];    
    if (self != nil){
        
        delayPerUnit = [dictionary floatForKey:@"delayPerUnit"];
        offset = [dictionary pointForKey:@"offset"];
        
        notifications= [[NSDictionary alloc] initWithDictionary:[dictionary objectForKey:@"notifications"]];
        
        spriteframeName= [[NSString alloc] initWithString:[dictionary objectForKey:@"spriteframe"]];

//        NSLog(@">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>");
//        NSLog(@"SPRITE FRAME NAME %@", spriteframeName);
//
//        
        rect = [dictionary rectForKey:@"Frame"];
        rect = CC_RECT_POINTS_TO_PIXELS(rect);
        
//        NSLog(@"IMAGE FILE %@", [sprite imageFile]);
        
        rect = [[LHSettings sharedInstance] transformedTextureRect:rect
                                                          forImage:[sprite imageFile]];
        
//        NSLog(@"RECT %f %f %f %f", rect.origin.x, rect.origin.y, rect.size.width, rect.size.height);
        spriteFrameOffset = [dictionary pointForKey:@"TextureOffset"];

        spriteFrameOffset.x *= CC_CONTENT_SCALE_FACTOR();
        spriteFrameOffset.y *= CC_CONTENT_SCALE_FACTOR();
        
        if([[LHSettings sharedInstance] isHDImage:[sprite imageFile]]){
            spriteFrameOffset.x *= 2.0f;
            spriteFrameOffset.y *= 2.0f;
        }

//        spriteFrameOffset = [[LHSettings sharedInstance] transformedPoint:spriteFrameOffset
//                                                                 forImage:[sprite imageFile]];
        
        CGPoint tempOffset = spriteFrameOffset;
        
        tempOffset.x += offset.x;
        tempOffset.y -= offset.y;

//        if(![[LHSettings sharedInstance] isHDImage:[sprite imageFile]]){
//            tempOffset.x /= 2.0f;
//            tempOffset.y /= 2.0f;
//        }
        offset = tempOffset;
        
        
        rectIsRotated = [dictionary boolForKey:@"IsRotated"];
        
        
        spriteFrameSize = [dictionary sizeForKey:@"SpriteSize"];
                
        spriteFrameSize.width *= CC_CONTENT_SCALE_FACTOR();
        spriteFrameSize.height *= CC_CONTENT_SCALE_FACTOR();
        
        if([[LHSettings sharedInstance] isHDImage:[sprite imageFile]]){
            spriteFrameSize.width *= 2.0f;
            spriteFrameSize.height *= 2.0f;
        }
    }
    return self;
}

+(id)frameWithDictionary:(NSDictionary*)dictionary sprite:(LHSprite*)sprite{
#ifndef LH_ARC_ENABLED
    return [[[self alloc] initWithDictionary:dictionary sprite:sprite] autorelease];
#else
    return [[self alloc] initWithDictionary:dictionary sprite:sprite];
#endif 
}
@end
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
@interface LHAnimationNode (Private)

@end
////////////////////////////////////////////////////////////////////////////////
@implementation LHAnimationNode
@synthesize shSceneName;
@synthesize uniqueName;
@synthesize sheetName;
@synthesize sheetImage;
@synthesize delayPerUnit;
@synthesize loop;
@synthesize repetitions;
@synthesize restoreOriginalFrame;
@synthesize sprite;
@synthesize paused;
////////////////////////////////////////////////////////////////////////////////
-(void) dealloc{
	
    frameChanged = false;
    paused = true;
//    NSLog(@"LH Animation Dealloc %@ %p", uniqueName, self);
#ifndef LH_ARC_ENABLED
    [shSceneName release];
    [uniqueName release];
    [sheetName release];
    [sheetImage release];
    [frames release];
    [oldSpriteFrame release];
    sprite = nil;
	[super dealloc];
#endif
}
////////////////////////////////////////////////////////////////////////////////
-(id) initWithDictionary:(NSDictionary*)dictionary
                onSprite:(LHSprite*)spr
               sceneName:(NSString*)scene{

    self = [super init];
    if (self != nil)
    {
//        NSLog(@"INIT ANIM");
        
        //this info will be from the spritehelper document
        //the info from the level is loaded by LHSprite
        shSceneName = [[NSString alloc] initWithString:scene];
        uniqueName = [[NSString alloc] initWithString:[dictionary stringForKey:@"UniqueName"]];
        sheetName = [[NSString alloc] initWithString:[dictionary stringForKey:@"SheetName"]];
        sheetImage = [[NSString alloc] initWithString:[dictionary stringForKey:@"SheetImage"]];
        
        
        
        restoreOriginalFrame = [dictionary boolForKey:@"RestoreOriginalFrame"];
        repetitions = [dictionary intForKey:@"Repetitions"];
        delayPerUnit = [dictionary floatForKey:@"DelayPerUnit"];
        loop = [dictionary boolForKey:@"Loop"];
        sprite = spr;
        oldRect = [sprite textureRect];
        
        #if COCOS2D_VERSION >= 0x00020000
        oldSpriteFrame = [sprite displayFrame];
        #else
        oldSpriteFrame = [sprite displayedFrame];
        #endif
        
        #ifndef LH_ARC_ENABLED
        [oldSpriteFrame retain];
        #endif
        
        repetitionsPerformed = 0;
        currentFrame = 0;
        elapsedFrameTime = 0.0f;
        NSArray* framesInfo = [dictionary objectForKey:@"Frames"];
        
        frames = [[NSMutableArray alloc] init];
        for(NSDictionary* frmInfo in framesInfo){
            [frames addObject:[LHAnimationFrameInfo frameWithDictionary:frmInfo 
                                                                 sprite:sprite]];
        } 
        
        paused = true;
    }
    return self;
}

+(id) animationWithDictionary:(NSDictionary*)dic 
                     onSprite:(LHSprite*)sprite sceneName:(NSString*)scene{
#ifndef LH_ARC_ENABLED
    return [[[self alloc] initWithDictionary:dic onSprite:sprite sceneName:scene] autorelease];
#else
    return [[self alloc] initWithDictionary:dic onSprite:sprite sceneName:scene];
#endif

}
-(void)setActiveFrameTexture
{
    if(nil == activeFrame) return;
                
#if COCOS2D_VERSION >= 0x00020000
        
    CCSpriteFrame* sprFrame = [CCSpriteFrame frameWithTexture:sprite.texture
                                                 rectInPixels:activeFrame.rect
                                                      rotated:activeFrame.rectIsRotated
                                                       offset:activeFrame.offset
                                                 originalSize:activeFrame.spriteFrameSize];
    
#else
    CCSpriteFrame* sprFrame = [CCSpriteFrame frameWithTexture:sprite.texture
                                                 rectInPixels:activeFrame.rect
                                                      rotated:activeFrame.rectIsRotated
                                                       offset:activeFrame.offset
                                                 originalSize:activeFrame.spriteFrameSize];
    
#endif
    
    [sprite setDisplayFrame:sprFrame];    
}

-(void)update:(ccTime)dt
{
    if(!activeFrame)
    {
        NSLog(@"ERROR: No active frame found in animation %@ on sprite %@", uniqueName, [sprite uniqueName]);
        return;
    }
        
    if(paused || [[LHSettings sharedInstance] levelPaused])
        return;
    
//    NSLog(@"FRAME %d - %@", currentFrame, uniqueName);
        
    elapsedFrameTime += dt;
    
    bool endedNotif = false;
    bool endedRep = false;
    frameChanged = false;
    
    if([activeFrame delayPerUnit]*delayPerUnit <= elapsedFrameTime){
        elapsedFrameTime = 0.0f;
        ++currentFrame;
    
        if(currentFrame >= (int)[frames count]){
            
            //we should trigger a notification that the animation has ended
            endedNotif = true;
            if(loop){
                currentFrame = 0;
            }
            else 
            {
                ++repetitionsPerformed;
                if(repetitionsPerformed >= repetitions)
                {
                    paused = true;
                    currentFrame = (int)[frames count] -1;
                    endedRep = true;
                }
                else {
                    if(restoreOriginalFrame || repetitionsPerformed < repetitions)
                        currentFrame = 0;
                    else {
                        currentFrame = (int)[frames count] -1;
                    }
                }
            }
        }
        
        [self setFrame:currentFrame];
        frameChanged = true;
    }
    
    if(sprite)
    {
        if(endedNotif){

            if(endedRep){
                [self setPaused:YES];
                [self restoreFrame];
            }
            
            [[NSNotificationCenter defaultCenter] postNotificationName:LHAnimationHasEndedNotification
                                                                object:sprite
                                                              userInfo:nil];
            if(endedRep){

                [[NSNotificationCenter defaultCenter] postNotificationName:LHAnimationHasEndedAllRepetitionsNotification
                                                                    object:sprite
                                                                  userInfo:nil];
                
                return;//animation is removed so dont go any further or else exc_bad_access since all objets are released
            }
        }
        
        if(frameChanged)
        {   
            //check if this frame has any info and trigger a notification if it has
            //we dont trigger frame changed notifications for every frame because 
            //it may impact performance - we trigger only where user is looking for info
            if(activeFrame && [activeFrame notifications] && [[[activeFrame notifications] allKeys] count] > 0)
            {
                NSDictionary* notifDict = [NSDictionary dictionaryWithObjects:[NSArray arrayWithObjects:
                                                                               [activeFrame notifications],
                                                                               [activeFrame spriteframeName], nil]
                                                                      forKeys:[NSArray arrayWithObjects:    
                                                                               LHAnimationUserInfo,
                                                                               LHAnimationFrameName, nil]];
            
                [[NSNotificationCenter defaultCenter] postNotificationName:LHAnimationFrameNotification
                                                                    object:sprite
                                                                  userInfo:notifDict];
            }
        }
    }
}
//------------------------------------------------------------------------------
-(void)prepare
{
    currentFrame = 0;
    repetitionsPerformed = 0;
    elapsedFrameTime = 0.0f;
    if([frames count] > 0)
        activeFrame = [frames objectAtIndex:0];
    else {
        activeFrame = nil;
    } 
    
    [self setActiveFrameTexture];
}
//------------------------------------------------------------------------------
-(void)play{
    paused = false;
}
//------------------------------------------------------------------------------
-(void)restart{
    [self prepare];
    [self play];
}
//------------------------------------------------------------------------------
-(int)numberOfFrames{
    return (int)[frames count];
}
//------------------------------------------------------------------------------
-(void)setFrame:(int)frm{
    if(frm >= 0 && frm < (int)[frames count]){
        currentFrame = frm;
        activeFrame = [frames objectAtIndex:(NSUInteger)currentFrame];        
        [self setActiveFrameTexture];
    }
}
//------------------------------------------------------------------------------
-(int)currentFrame{
    return currentFrame;
}
//------------------------------------------------------------------------------
-(void) nextFrame{
    
    int curFrame = [self currentFrame];    
    curFrame +=1;
    
    if(curFrame >= 0 && curFrame < [self numberOfFrames]){
        [self setFrame:curFrame];
    }    
}
//------------------------------------------------------------------------------
-(void) prevFrame{
    
    int curFrame = [self currentFrame];
    curFrame -=1;
    
    if(curFrame >= 0 && curFrame < (int)[self numberOfFrames]){
        [self setFrame:curFrame];
    }        
}
//------------------------------------------------------------------------------
-(void) nextFrameAndRepeat{
    
    int curFrame = [self currentFrame];
    curFrame +=1;
    
    if(curFrame >= [self numberOfFrames]){
        curFrame = 0;
    }
    
    if(curFrame >= 0 && curFrame < [self numberOfFrames]){
        [self setFrame:curFrame];
    }    
}
//------------------------------------------------------------------------------
-(void) prevFrameAndRepeat{
    
    int curFrame = [self currentFrame];
    curFrame -=1;
    
    if(curFrame < 0){
        curFrame = [self numberOfFrames] - 1;        
    }
    
    if(curFrame >= 0 && curFrame < (int)[self numberOfFrames]){
        [self setFrame:curFrame];
    }        
}
//------------------------------------------------------------------------------
-(bool) isAtLastFrame{
    return ([self numberOfFrames]-1 == [self currentFrame]);
}
//------------------------------------------------------------------------------
-(void)restoreFrame{
    
    if(!restoreOriginalFrame){
        return;
    }
    //we do this so that we dont lose touches
    [sprite performSelector:@selector(setPrepareAnimInProgress:)
                 withObject:[NSNumber numberWithBool:YES]];
    
    if(oldBatch){
        [sprite removeFromParentAndCleanup:NO];
        [sprite setTexture:oldTexture];
        [oldBatch addChild:sprite z:[sprite zOrder]];
    }
    else if(oldTexture){
        [sprite setTexture:oldTexture];
    }
    if(oldSpriteFrame){
        [sprite setDisplayFrame:oldSpriteFrame];
    }
    
    //we do this so that we dont lose touches
    [sprite performSelector:@selector(setPrepareAnimInProgress:)
                 withObject:[NSNumber numberWithBool:NO]];
}
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
-(void)setOldBatch:(LHBatch*)b{
    oldBatch = b;
    oldTexture = [b texture];
}
-(void)setOldTexture:(CCTexture2D*)tex{
    oldTexture = tex;
    oldBatch = nil;
}
-(void)setOldRect:(CGRect)r{
    oldRect = r;
}
//------------------------------------------------------------------------------
-(float)totalTime{
    float t = 0.0f;
    for(LHAnimationFrameInfo* frm in frames){
        t += delayPerUnit*[frm delayPerUnit];
    }
    return t;
}
@end
