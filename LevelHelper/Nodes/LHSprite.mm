//  This file was generated by LevelHelper
//  http://www.levelhelper.org
//
//  LevelHelperLoader.mm
//  Created by Bogdan Vladu
//  Copyright 2011 Bogdan Vladu. All rights reserved.
////////////////////////////////////////////////////////////////////////////////
//
//  This software is provided 'as-is', without any express or implied
//  warranty.  In no event will the authors be held liable for any damages
//  arising from the use of this software.
//  Permission is granted to anyone to use this software for any purpose,
//  including commercial applications, and to alter it and redistribute it
//  freely, subject to the following restrictions:
//  The origin of this software must not be misrepresented; you must not
//  claim that you wrote the original software. If you use this software
//  in a product, an acknowledgment in the product documentation would be
//  appreciated but is not required.
//  Altered source versions must be plainly marked as such, and must not be
//  misrepresented as being the original software.
//  This notice may not be removed or altered from any source distribution.
//  By "software" the author refers to this code file and not the application 
//  that was used to generate this file.
//
////////////////////////////////////////////////////////////////////////////////
#import "LHSprite.h"

#import "SHDocumentLoader.h"

#import "LHSettings.h"
#import "LHPathNode.h"
#import "LHParallaxNode.h"
#import "LHAnimationNode.h"
#import "LevelHelperLoader.h"
#import "LHTouchMgr.h"
#import "LHCuttingEngineMgr.h"
#import "LHJoint.h"
#import "LHBezier.h"
#import "LHFixture.h"
#import "LHLayer.h"
#import "LHDictionaryExt.h"

#import "LHCustomClasses.h"


static int untitledSpritesCount = 0;
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
@interface LHBezier (LH_BEZIER_SPRITE_EXT) 
-(NSArray*)pathPoints;
@end
@implementation LHBezier (LH_BEZIER_SPRITE_EXT)
-(NSArray*)pathPoints{
    return pathPoints;
}
@end


@interface LHSprite (Private)

@end
////////////////////////////////////////////////////////////////////////////////
@implementation LHSprite
@synthesize usesOverloadedTransformations;
@synthesize usesUVTransformation;
@synthesize realScale;
@synthesize swallowTouches;
@synthesize touchPriority;
@synthesize touchesDisabled;
@synthesize shSceneName;
@synthesize shSheetName;
@synthesize shSpriteName;
////////////////////////////////////////////////////////////////////////////////
//-(oneway void)release{
//    NSLog(@"LHSPrite release %@ %d", uniqueName, [self retainCount]);
//    [super release];
//}

-(void)removeSelf{
    
#ifdef LH_USE_BOX2D
    if(body){
        if(body->GetWorld()->IsLocked()){
            [[LHSettings sharedInstance] markSpriteForRemoval:self];
            return;
        }
    }
#endif
    
  //  NSLog(@"SPRITE REMOVE %@ SELF %d", uniqueName, [self retainCount]);
    [self removeFromParentAndCleanup:YES];
}


-(void) onExit{
//    NSLog(@"LH SPrite %@ onExit", uniqueName);
    if(!prepareAnimInProgress)
    {
        [self removeTouchObserver];
    }
}
-(void)setPrepareAnimInProgress:(NSNumber*)val{
    
    prepareAnimInProgress = [val boolValue];
}

-(void) dealloc{

    //    NSLog(@"LH Sprite Dealloc %@ - %p", uniqueName, self);
    
    [self stopAnimation];

    [self stopPathMovement];
//    [self removeTouchObserver];//this is called in onExit
    
    [self unscheduleAllSelectors];
    
#ifdef LH_USE_BOX2D
    [self removeBodyFromWorld];
#endif
  

    if(NULL != parallaxFollowingThisSprite)
        [parallaxFollowingThisSprite followSprite:NULL 
                                changePositionOnX:false 
                                changePositionOnY:false];

    if(NULL != spriteIsInParallax){
        [spriteIsInParallax removeChild:self];
        spriteIsInParallax = nil;
    }
                
#ifndef LH_ARC_ENABLED   

    [preloadedAnimations release];
    
    if(fixturesInfo){
        [fixturesInfo release];
        fixturesInfo = nil;
    }
    
    if(fixturesObj)
        [fixturesObj release];
    
        
    if(pathDefaultName){
        [pathDefaultName release];
        pathDefaultName = nil;
    }
    
    if(userCustomInfo){
        [userCustomInfo release];
        userCustomInfo = nil;
    }

    if(shSceneName){
        [shSceneName release];
        shSceneName = nil;
    }
    
    [shSheetName release];
    [shSpriteName release];
    
    if(imageFile)
        [imageFile release];
        
    [uniqueName release];
#endif    
    
    preloadedAnimations = nil;
    touchBeginObserver = nil;
    touchMovedObserver = nil;
    touchEndedObserver = nil;

#ifndef LH_ARC_ENABLED   
	[super dealloc];
#endif
}
////////////////////////////////////////////////////////////////////////////////
-(void) loadUserCustomInfoFromDictionary:(NSDictionary*)dictionary{
    userCustomInfo = nil;
    if(!dictionary)return;
    
    NSString* className = [dictionary stringForKey:@"ClassName"];
    Class customClass = NSClassFromString(className);

    if(!customClass) return;
    
    userCustomInfo = [customClass performSelector:@selector(customClassInstance)];
#ifndef LH_ARC_ENABLED
    [userCustomInfo retain];
#endif
    [userCustomInfo performSelector:@selector(setPropertiesFromDictionary:) withObject:[dictionary objectForKey:@"ClassRepresentation"]];
}
//------------------------------------------------------------------------------
#ifdef LH_USE_BOX2D
-(void) createFixturesFromInfoOnBody{
    
    if(fixturesInfo && fixturesObj)
    {
        [fixturesObj removeAllObjects];
        
        if(body->GetWorld()->IsLocked())
        {
            NSLog(@"ERROR: Cannot create fixture for body, because Box2d is Locked. Try changing the location on where you want to change the body. e.g Try doing it at the end of tick function");
            return;
        }
        
        b2Fixture* curFixture = body->GetFixtureList();
        
        while(curFixture)
        {
            b2Fixture* tempNextFix = curFixture->GetNext();
            body->DestroyFixture(curFixture);
            curFixture = tempNextFix;
        }
        
        for(NSDictionary* fixInfo in fixturesInfo)
        {
            LHFixture* lhFixture = [LHFixture fixtureWithDictionary:fixInfo body:body sprite:self];
            [fixturesObj addObject:lhFixture];
        }
    }
}
//------------------------------------------------------------------------------
-(void)createBodyFromDefaultValuesWithType:(b2BodyType)bDefaultType{
    
    b2BodyDef bodyDef;
    
	bodyDef.type = bDefaultType;
	
	CGPoint pos = self.position;
	bodyDef.position.Set(pos.x/[[LHSettings sharedInstance] lhPtmRatio],
                         pos.y/[[LHSettings sharedInstance] lhPtmRatio]);
    
	bodyDef.angle = CC_DEGREES_TO_RADIANS(-1*self.rotation);
    
#ifndef LH_ARC_ENABLED
    bodyDef.userData = self;
#else
    bodyDef.userData = (__bridge void*)self;
#endif
    
    b2World* world = [[LHSettings sharedInstance] activeBox2dWorld];
    
    if(world == NULL)
        return;
    
    body = world->CreateBody(&bodyDef);
	body->SetFixedRotation(bDefaultFixRotation);
    
    //we use this define to figure out which version of Box2d the user has
    //its not nice that box2d does not have a compile time versioning just like cocos2d
#ifdef B2_EDGE_SHAPE_H
    body->SetGravityScale(bDefaultGravityScale);
#endif
	body->SetSleepingAllowed(bDefaultCanSleep);
    body->SetBullet(bDefaultIsBullet);
    
    body->SetLinearVelocity(bDefaultLinearVelocity);
    
    body->SetAngularVelocity(bDefaultAngularVelocity);
    body->SetLinearDamping(bDefaultLinearDamping);
    body->SetAngularDamping(bDefaultAngularDamping);
}

-(void) loadPhysicalInformationFromDictionary:(NSDictionary*)dictionary{

    body = NULL;
    
    if(nil == dictionary)
        return;
    
    b2World* world = [[LHSettings sharedInstance] activeBox2dWorld];

    if(world == NULL)
        return;
//    NSAssert(world!=nil, @"Box2d World must not be nil");
    
    bDefaultFixRotation =[dictionary boolForKey:@"FixedRot"];
    bDefaultGravityScale = [dictionary floatForKey:@"GravityScale"];
    bDefaultCanSleep = [dictionary boolForKey:@"CanSleep"];
    bDefaultIsBullet = [dictionary boolForKey:@"IsBullet"];
    
    CGPoint linearVelocity = [dictionary pointForKey:@"LinearVelocity"];
    bDefaultLinearVelocity = b2Vec2(linearVelocity.x, linearVelocity.y);
    bDefaultAngularVelocity = [dictionary floatForKey:@"AngularVelocity"];
    bDefaultLinearDamping = [dictionary floatForKey:@"LinearDamping"];
    bDefaultAngularDamping = [dictionary floatForKey:@"AngularDamping"];
    
    int pType = [dictionary intForKey:@"Type"];//LH
    
	if(pType == 3) //"NO_PHYSIC"
        return;

    usePhysicsForTouches = true;

    [self createBodyFromDefaultValuesWithType:(b2BodyType)pType];
	
    NSArray* fixInfo = [dictionary objectForKey:@"SH_ComplexShapes"];
    fixturesInfo = [[NSArray alloc] initWithArray:fixInfo];
    
    fixturesObj = [[NSMutableArray alloc] init];
    
    [self createFixturesFromInfoOnBody];    
}
#endif

-(void) loadAnimationsInformationFromDictionary:(NSDictionary*)dictionary{
    
    if(dictionary ==nil) return; //When sprite is loaded from SH dictionary this info is not available;
    
    //if sprite has no animation dictionary will be empty in order to make the level size smaller
    //so we test here to see if we should load anything
    if(![dictionary objectForKey:@"AnimName"]) return;
        
    
    [self prepareAnimationNamed:[dictionary stringForKey:@"AnimName"] 
                    fromSHScene:[dictionary stringForKey:@"SHScene"]];
    
    if(!animation) return;//something has gone wrong with animation loading
    
    [preloadedAnimations addObject:animation];
    
    if([dictionary boolForKey:@"AnimAtStart"])//we should pause the animation
        [animation play];
    
    [animation setLoop:[dictionary boolForKey:@"AnimLoop"]];
    [animation setRepetitions:[dictionary intForKey:@"AnimRepetitions"]];
    [animation setRestoreOriginalFrame:[dictionary boolForKey:@"AnimRestoreOriginalFrame"]];
    [animation setDelayPerUnit:[dictionary floatForKey:@"AnimSpeed"]];
    
    
    
    NSArray* otherAnims = [dictionary objectForKey:@"OtherAnimations"];
    
    for(NSDictionary* otherAnimDict in otherAnims)
    {
        NSString* animName = [otherAnimDict objectForKey:@"AnimName"];
        NSString* animScene = [otherAnimDict objectForKey:@"SHScene"];
        
        NSDictionary* shAnimInfo = [[SHDocumentLoader sharedInstance] dictionaryForAnimationNamed:animName
                                                                                       inDocument:animScene];

        LHAnimationNode* otherAn =  [LHAnimationNode animationWithDictionary:shAnimInfo
                                                                    onSprite:self
                                                                   sceneName:animScene];
        
        [otherAn setLoop:[otherAnimDict boolForKey:@"AnimLoop"]];
        [otherAn setRepetitions:[otherAnimDict intForKey:@"AnimRepetitions"]];
        [otherAn setRestoreOriginalFrame:[otherAnimDict boolForKey:@"AnimRestoreOriginalFrame"]];
        [otherAn setDelayPerUnit:[otherAnimDict floatForKey:@"AnimSpeed"]];
        
        [preloadedAnimations addObject:otherAn];
    }
}

-(void)loadPathMovementFromDictionary:(NSDictionary*)dictionary{
    if(!dictionary)return;
    
    //at this point we may not have a LHBezier in the level 
    //so we create the path after the level is fully loaded
    //but we save the path properties here
    if(![dictionary objectForKey:@"PathName"]) return;
       
    pathDefaultFlipX = [dictionary boolForKey:@"PathFlipX"];
    pathDefaultFlipY = [dictionary boolForKey:@"PathFlipY"];
    pathDefaultIsCyclic = [dictionary boolForKey:@"PathIsCyclic"];
    pathDefaultRelativeMove = [dictionary boolForKey:@"PathMoveDelta"];
    pathDefaultName = [[NSString alloc] initWithString:[dictionary stringForKey:@"PathName"]];
    pathDefaultOrientation = [dictionary intForKey:@"PathOrientation"];
    pathDefaultRestartOtherEnd = [dictionary boolForKey:@"PathOtherEnd"];
    pathDefaultSpeed = [dictionary floatForKey:@"PathSpeed"];
    pathStartAtLaunch= [dictionary boolForKey:@"PathStartAtLaunch"];
    pathDefaultStartPoint = [dictionary intForKey:@"PathStartPoint"];
}

-(void) loadInformationFromDictionary:(NSDictionary*)dictionary{
    
    if(nil != uniqueName)
        return; //compatibility with cocos2d 2.0
        
    if(nil != [dictionary objectForKey:@"UniqueName"]){
        uniqueName = [[NSMutableString alloc] initWithString:[dictionary stringForKey:@"UniqueName"]];
    }else {
        uniqueName = [[NSMutableString alloc] initWithFormat:@"UntitledSprite_%d", untitledSpritesCount];
        ++untitledSpritesCount;
    }
        
    if([dictionary objectForKey:@"SHSceneName"])
        shSceneName = [[NSString alloc] initWithString:[dictionary stringForKey:@"SHSceneName"]];
    
    if([dictionary objectForKey:@"SHSheetName"])
        shSheetName = [[NSString alloc] initWithString:[dictionary stringForKey:@"SHSheetName"]];
    if([dictionary objectForKey:@"SHSpriteName"])
        shSpriteName= [[NSString alloc] initWithString:[dictionary stringForKey:@"SHSpriteName"]];
    
    NSDictionary* texDict = [dictionary objectForKey:@"TextureProperties"];
    

    preloadedAnimations = [[NSMutableArray alloc] init];
    
    NSDictionary* shTexDict = texDict;
    if(![dictionary objectForKey:@"IsSHSprite"])//we may be loading directly from a sh dictionary
    {
        NSDictionary* shDict = [[SHDocumentLoader sharedInstance] dictionaryForSpriteNamed:[dictionary stringForKey:@"SHSpriteName"]
                                                                          inSheetNamed:[dictionary objectForKey:@"SHSheetName"]
                                                                            inDocument:[dictionary objectForKey:@"SHSceneName"]];

        if(shDict)
            shTexDict = [shDict objectForKey:@"TextureProperties"];
    }
    
    //CGRect rectInPixels = self.textureRect;
    CGRect rectInPixels = [shTexDict rectForKey:@"Frame"];
    CGSize contentSize = [shTexDict sizeForKey:@"SpriteSize"];
    originalTextureOffset = [shTexDict pointForKey:@"TextureOffset"];
    
    NSString* sheetImg = [dictionary objectForKey:@"SheetImage"];
    NSString* sheetImgHD = [dictionary objectForKey:@"SheetImage-HD"];
    //if image and image hd are the same it means no-resampling has been used
    //and we should not transform the texture rectagnel
    usesUVTransformation = true;
    
    if(sheetImgHD != nil && [sheetImg isEqualToString:sheetImgHD]){
        usesUVTransformation = false;
    }
        
    if(usesUVTransformation){
        rectInPixels = [[LHSettings sharedInstance] transformedTextureRect:rectInPixels forImage:[self imageFile]];
        rectInPixels = CC_RECT_POINTS_TO_PIXELS(rectInPixels);
    
        contentSize = [[LHSettings sharedInstance] transformedSize:contentSize forImage:[self imageFile]];
        contentSize.width *= CC_CONTENT_SCALE_FACTOR();
        contentSize.height*= CC_CONTENT_SCALE_FACTOR();

        CGSize texOffsetSize = [[LHSettings sharedInstance] transformedSize:CGSizeMake(originalTextureOffset.x, originalTextureOffset.y) forImage:[self imageFile]];
        originalTextureOffset.x = texOffsetSize.width;
        originalTextureOffset.y = texOffsetSize.height;
        originalTextureOffset.x *= CC_CONTENT_SCALE_FACTOR();
        originalTextureOffset.y *= CC_CONTENT_SCALE_FACTOR();
    }
    
//    NSLog(@"SPRITE INFO %@", uniqueName);
//    NSLog(@"....................................................................");
//    NSLog(@"CONTENT SIZE %f %f", contentSize.width, contentSize.height);
//    NSLog(@"SPR RECT %f %f %f %f", rectInPixels.origin.x, rectInPixels.origin.y, rectInPixels.size.width, rectInPixels.size.height);
//    NSLog(@"OFFSET %f %f", originalTextureOffset.x, originalTextureOffset.y);
//    NSLog(@"ROTATED %d", [shTexDict boolForKey:@"IsRotated"] );
//    NSLog(@"TEXTURE %d - %d %d", self.texture.name, self.texture.pixelsWide, self.texture.pixelsHigh);
//    NSLog(@"TEX NAME %@", [self imageFile]);
//    
    CCSpriteFrame* sprFrame = [CCSpriteFrame frameWithTexture:self.texture
                                                 rectInPixels:rectInPixels
                                                      rotated:[shTexDict boolForKey:@"IsRotated"] 
                                                       offset:originalTextureOffset
                                                 originalSize:contentSize];
    
    [self setDisplayFrame:sprFrame];

//    CGPoint scale = [texDict pointForKey:@"Scale"];
    
    bool flipX = [texDict boolForKey:@"FlipX"];
    bool flipY = [texDict boolForKey:@"FlipY"];
    
    [self setFlipX:flipX];
    [self setFlipY:flipY];
    
    CGPoint scale = [texDict pointForKey:@"Scale"];
    
    if(usesUVTransformation)
        scale = [[LHSettings sharedInstance] transformedScalePointToCocos2d:scale];
    
    [self setScaleX:(scale.x)];
    [self setScaleY:(scale.y)];
    
    realScale = CGSizeMake(scale.x, scale.y);

    if(usesUVTransformation)
        realScale = CGSizeMake(scale.x*[[LHSettings sharedInstance] convertRatio].x,
                               scale.y*[[LHSettings sharedInstance] convertRatio].y);
    
    CGPoint position = [texDict pointForKey:@"Position"];

    if(usesUVTransformation)
        position = [[LHSettings sharedInstance] transformedPointToCocos2d:position];

    [self setPosition:ccp((int)position.x, (int)position.y)];
    
    
    [self setRotation:[texDict intForKey:@"Angle"]];
    [self setColor:[texDict colorForKey:@"Color"]];
    [self setVisible:[texDict boolForKey:@"IsDrawable"]];
    [self setOpacity:(GLubyte)([texDict floatForKey:@"Opacity"]*255.0f)];
    [self setTag:[texDict intForKey:@"Tag"]];
    zOrder_ = [texDict intForKey:@"ZOrder"];
    
    NSDictionary* phyDict = [dictionary objectForKey:@"PhysicProperties"];
    if([phyDict boolForKey:@"HandledBySH"] && ![dictionary objectForKey:@"IsSHSprite"])
    {        
        NSDictionary* sprDict = [[SHDocumentLoader sharedInstance] dictionaryForSpriteNamed:shSpriteName
                                                                               inSheetNamed:shSheetName
                                                                                 inDocument:shSceneName];
        phyDict = [sprDict objectForKey:@"PhysicProperties"];
    }
    
     //we do this because we need the batch to contain the sprite before loading any animation
    if([self batchNode]){
        [[self batchNode] addChild:self z:zOrder_];
    }

    originalRect = self.textureRect;

#ifdef LH_USE_BOX2D
    [self loadPhysicalInformationFromDictionary:phyDict];
#endif
    [self loadAnimationsInformationFromDictionary:[dictionary objectForKey:@"AnimationsProperties"]];
    
    [self loadUserCustomInfoFromDictionary:[dictionary objectForKey:@"CustomClassInfo"]];
    [self loadPathMovementFromDictionary:[dictionary objectForKey:@"PathProperties"]];
    
    pathNode = nil;
    spriteIsInParallax = nil;
    
    touchBeginObserver = nil;
    touchMovedObserver = nil;
    touchEndedObserver = nil;
    
    tagTouchBeginObserver = nil;
    tagTouchMovedObserver = nil;
    tagTouchEndedObserver = nil;
    
    usesOverloadedTransformations = false;

    [LevelHelperLoader setTouchDispatcherForObject:self tag:(int)[self tag]];
    
    [self scheduleUpdate];
}
-(void)setShSceneName:(NSString *)sceneName
{
    if(shSceneName)
    {
#ifndef LH_ARC_ENABLED
        [shSceneName release];
#endif
    }
    shSceneName = [[NSString alloc] initWithString:sceneName];
}

-(LevelHelperLoader*) parentLoader{

    CCNode* layerParent = self.parent;
    
    while (layerParent && ![layerParent isKindOfClass:[LHLayer class]]){
        layerParent = layerParent.parent;
    }
    
    if(layerParent && [layerParent isKindOfClass:[LHLayer class]]) {
        return [(LHLayer*)layerParent parentLoader];
    }
    return nil;
}
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
-(id)initBatchSpriteWithDictionary:(NSDictionary*)dictionary batch:(LHBatch*)batch{
        
    NSDictionary* texDict = [dictionary objectForKey:@"TextureProperties"];
    CGRect rect = LHRectFromString([texDict objectForKey:@"Frame"]);    

    rect = [[LHSettings sharedInstance] transformedTextureRect:rect forImage:[batch imagePath]];
        
#if COCOS2D_VERSION >= 0x00020000
    self = [super initWithTexture:[batch texture] rect:rect];
    
    [self setBatchNode:batch];
#else
    self = [super initWithBatchNode:batch rect:rect];
#endif
    
    if (self != nil){        
        [self setImageFile:[batch imagePath]];        
        [self loadInformationFromDictionary:dictionary];
    }
    return self;
}
//------------------------------------------------------------------------------
+(id)batchSpriteWithDictionary:(NSDictionary*)dictionary batch:(LHBatch*)batch{

#ifndef LH_ARC_ENABLED
    return [[[self alloc] initBatchSpriteWithDictionary:dictionary batch:batch] autorelease];
#else
    return [[self alloc] initBatchSpriteWithDictionary:dictionary batch:batch];
#endif     
}
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
-(id)initWithDictionary:(NSDictionary*)dictionary{
    
    NSString* sheetImg = [dictionary objectForKey:@"SheetImage"];
    NSString* imgPath = [[LHSettings sharedInstance] imagePath:sheetImg];
    NSAssert(imgPath!=nil, @"Image path must not be nil");
    
    NSDictionary* texDict = [dictionary objectForKey:@"TextureProperties"];
    CGRect rect = LHRectFromString([texDict objectForKey:@"Frame"]);
    
    NSString* sheetImgHD = [dictionary objectForKey:@"SheetImage-HD"];
    //if image and image hd are the same it means no-resampling has been used
    //and we should not transform the texture rectagnel
    if(![sheetImg isEqualToString:sheetImgHD])
        rect = [[LHSettings sharedInstance] transformedTextureRect:rect forImage:imgPath];
    
    self = [super initWithFile:imgPath rect:rect];    
    if (self != nil){
        [self setImageFile:imgPath];
        [self loadInformationFromDictionary:dictionary];
    }
    return self;
}
//------------------------------------------------------------------------------
+(id)spriteWithDictionary:(NSDictionary*)dictionary{
    
#ifndef LH_ARC_ENABLED
    return [[[self alloc] initWithDictionary:dictionary] autorelease];
#else
    return [[self alloc] initWithDictionary:dictionary];
#endif 
}
-(void)postInit{
    //nothing to do - method provided for overloading sprites
}
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
+(id)spriteWithName:(NSString*)spriteName 
          fromSheet:(NSString*)sheetName 
             SHFile:(NSString*)spriteHelperFile{
    
    NSDictionary* dictionary = [[SHDocumentLoader sharedInstance] dictionaryForSpriteNamed:spriteName 
                                                                              inSheetNamed:sheetName 
                                                                                inDocument:spriteHelperFile];
#ifndef LH_ARC_ENABLED
    LHSprite* sprite = [[[LHSprite alloc] initWithDictionary:dictionary] autorelease];
#else
    LHSprite* sprite = [[LHSprite alloc] initWithDictionary:dictionary];
#endif 
    
    if(sprite){      
        [sprite setShSceneName:spriteHelperFile];
    }
    return sprite;
}
//------------------------------------------------------------------------------
+(id)batchSpriteWithName:(NSString*)spriteName 
                   batch:(LHBatch*)batch{
    
    NSAssert(spriteName!=nil, @"Sprite name  must not be nil");
    NSAssert(batch!=nil, @"Batch must not be nil");
        
    NSDictionary* dictionary = [[SHDocumentLoader sharedInstance] dictionaryForSpriteNamed:spriteName 
                                                                              inSheetNamed:[batch uniqueName]
                                                                                inDocument:[batch shFile]];
#ifndef LH_ARC_ENABLED
    LHSprite* sprite = [[[LHSprite alloc] initBatchSpriteWithDictionary:dictionary batch:batch] autorelease];
#else
    LHSprite* sprite = [[LHSprite alloc] initBatchSpriteWithDictionary:dictionary batch:batch];
#endif     
    
    if(sprite){
        //[batch addChild:sprite z:[sprite zOrder]];
        [sprite setShSceneName:[batch shFile]];
    }
    return sprite;
}
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
-(void) setUniqueName:(NSString*)name{
    NSAssert(name!=nil, @"UniqueName must not be nil");
    [uniqueName setString:name];
}
//------------------------------------------------------------------------------
-(NSString*)uniqueName{
    return uniqueName;   
}
//------------------------------------------------------------------------------
#ifdef LH_USE_BOX2D
-(void) setBody:(b2Body*)bd{
    NSAssert(bd!=nil, @"b2Body must not be nil");
    body = bd;
}
//------------------------------------------------------------------------------
-(b2Body*)body{
    return body;
}
//------------------------------------------------------------------------------
-(bool) removeBodyFromWorld{
    
//    NSLog(@"RMOVE BODY %p", body);
    if(NULL != body){
		b2World* _world = body->GetWorld();
		if(0 != _world){
                       
            NSMutableArray* list = (NSMutableArray*)[self jointList];
            for(LHJoint* jt in list){
                [jt setShouldDestroyJointOnDealloc:NO];
                [jt removeSelf];
            }
            [list removeAllObjects];
            
			_world->DestroyBody(body);
			body = NULL;
            
            return true;
		}
	}
    return false;
}
#endif
////////////////////////////////////////////////////////////////////////////////
-(NSString*)imageFile{
    return imageFile;
}
-(void)setImageFile:(NSString*)img{
    
#ifndef LH_ARC_ENABLED
    if(imageFile)
        [imageFile release];
#endif
    
    imageFile = [[NSString alloc] initWithString:img];
}
//------------------------------------------------------------------------------
-(CGRect)originalRect{
    return originalRect;
}
-(void)setOriginalRect:(CGRect)rect{
    originalRect = rect;
}
-(CGPoint)originalTextureOffset{
    return originalTextureOffset;
}
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
-(void)setPosition:(CGPoint)pos
{
    if(usesOverloadedTransformations)
        [self transformPosition:pos];
    else {
        [super setPosition:pos];
    }
}
-(void)setRotation:(float)rot
{
    if(usesOverloadedTransformations)
        [self transformRotation:rot];
    else {
        [super setRotation:rot];
    }
}
//------------------------------------------------------------------------------
-(void)setScale:(float)scale{

    if(usesOverloadedTransformations)
        [self transformScale:scale];
    else {
        [super setScale:scale];
    }
}
-(void)setScaleX:(float)scaleX{
    if(usesOverloadedTransformations)
        [self transformScaleX:scaleX];
    else {
        [super setScaleX:scaleX];
    }
}

-(void)setScaleY:(float)scaleY{
    if(usesOverloadedTransformations)
        [self transformScaleY:scaleY];
    else {
        [super setScaleY:scaleY];
    }
}
//------------------------------------------------------------------------------
-(void) transformPosition:(CGPoint)pos{
    [super setPosition:pos];
#ifdef LH_USE_BOX2D
    if(0 != body){
        b2Vec2 boxPosition = [LevelHelperLoader pointsToMeters:pos];
        float angle = CC_DEGREES_TO_RADIANS(-1*super.rotation);
        body->SetTransform(boxPosition, angle);
    }
#endif
}
//------------------------------------------------------------------------------
-(void)transformRotation:(float)rot{
    [super setRotation:rot];
#ifdef LH_USE_BOX2D
    if(0 != body){
        b2Vec2 boxPosition = [LevelHelperLoader pointsToMeters:super.position];
        float angle = CC_DEGREES_TO_RADIANS(-1*rot);
        body->SetTransform(boxPosition, angle);
    }
#endif
}
//------------------------------------------------------------------------------
-(void) transformScale:(float)scale{

    [super setScale:scale];
#ifdef LH_USE_BOX2D
    if(0 != body){
        [self createFixturesFromInfoOnBody];
    }
#endif
}
-(void) transformScaleX:(float)scaleX{
    [super setScaleX:scaleX];
#ifdef LH_USE_BOX2D
    if(0 != body){
        [self createFixturesFromInfoOnBody];        
    }
#endif
}
-(void) transformScaleY:(float)scaleY{
    [super setScaleY:scaleY];
#ifdef LH_USE_BOX2D
    if(0 != body){
        [self createFixturesFromInfoOnBody];
    }
#endif
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
-(void)update:(ccTime)dt{    
    
    if(animation){
        [animation update:dt];
    }
    
    if(pathNode)
        [pathNode update:dt];
}
//------------------------------------------------------------------------------
-(void) prepareAnimationNamed:(NSString*)animName fromSHScene:(NSString *)shScene{

    if(animation)
    {
        //if we already have the same animation active - reset it to frame 0
        if([[animation uniqueName] isEqualToString:animName] &&
           [[animation shSceneName] isEqualToString:shScene])
        {
            [animation setFrame:0];
            return;
        }
    }

    [self stopAnimation];
    //very important that prepareAnimInProgress is after stopAnimation or else touches will be removed
    prepareAnimInProgress = true;

    for(LHAnimationNode* anim in preloadedAnimations)
    {
        if([[anim uniqueName] isEqualToString:animName] &&
           [[[anim shSceneName] stringByDeletingPathExtension] isEqualToString:shScene])
        {
            #ifndef LH_ARC_ENABLED
            animation = [anim retain];
            #else
            animation = anim;
            #endif
            break;
        }
    }
    
    NSString* textureFile = nil;
    NSString* animSheet = nil;

    if(!animation)
    {
        NSDictionary* animDict = [[SHDocumentLoader sharedInstance] dictionaryForAnimationNamed:animName
                                                                                     inDocument:shScene];
             
        if(!animDict) {
            NSLog(@"ERROR: SpriteHelper document %@ for animation %@ needs to be updated. Animation is canceled.", shScene, animName);
            return;
        }
//        NSLog(@"NOT PRELOADED");
        
        textureFile = [animDict stringForKey:@"SheetImage"];
        animSheet = [animDict stringForKey:@"SheetName"];

        animation = [[LHAnimationNode alloc] initWithDictionary:animDict 
                                                       onSprite:self
                                                      sceneName:shScene];
    }
    else{
//        NSLog(@"PRELOAD 2");
        textureFile = [animation sheetImage];
        animSheet = [animation sheetName];
    }
    
//    if(![shSheetName isEqualToString:animSheet]){//causing a bug were if you prepare an animation from another image a second time it will use the initial texture of the sprite
    if(nil != textureFile){
        
      
        
        NSString* filePath = [[LHSettings sharedInstance] imagePath:textureFile];
        if(filePath){
            CCTexture2D* newTexture = [[CCTextureCache sharedTextureCache] addImage:filePath];
            
            if(newTexture && newTexture.name != self.texture.name){
                //if sprite is render by a batch node we need to remove if from the batch and 
                //move it on the layer that contains the batch
                LHBatch* parentBatch = (LHBatch*)[self batchNode];
                    
                if(parentBatch){
                    [self removeFromParentAndCleanup:NO];
                    
                    [animation setOldBatch:parentBatch];
                    //we need to keep the z order so its batch z + sprite z 
                    if([parentBatch parent]){
                        [[parentBatch parent] addChild:self z:[parentBatch zOrder] + [self zOrder]];
                    }
                    else {
                        NSLog(@"ERROR: Sprite is render by batch node, but batch node has no parent.");
                    }
                }   
                else {
                    [animation setOldTexture:self.texture];
                }
                
                [self setTexture:newTexture];
                #ifndef LH_ARC_ENABLED
                [shSheetName release];
                #endif
                shSheetName = [[NSString alloc] initWithString:animSheet];
            }
        }
    }
    else{
        #ifndef LH_ARC_ENABLED
        [animation release];
        #endif
        NSLog(@"ERROR: Image file %@ could not be found. Please add it in the resource folder.", textureFile);
    }

    if(animation){
        [animation prepare];
    
    }
    
    prepareAnimInProgress = false;
}
//------------------------------------------------------------------------------
//use this methods when you want to get notification about animation on a per sprite basis
-(void) setAnimationHasEndedObserver:(id)observer selector:(SEL)selector{
    animEndedObserver = observer;
    [[NSNotificationCenter defaultCenter] addObserver:observer
                                             selector:selector
                                                 name:LHAnimationHasEndedNotification
                                               object:self];
}
//------------------------------------------------------------------------------
-(void) setAnimationHasChangedFrameObserver:(id)observer selector:(SEL)selector{
    animChangedFrameObserver = observer;
    [[NSNotificationCenter defaultCenter] addObserver:observer
                                             selector:selector
                                                 name:LHAnimationFrameNotification
                                               object:self];
}
//------------------------------------------------------------------------------
-(void) setAnimationHasEndedAllRepetitionsObserver:(id)observer selector:(SEL)selector{
    
    animEndedAllRepObserver = observer;
    [[NSNotificationCenter defaultCenter] addObserver:observer
                                             selector:selector
                                                 name:LHAnimationHasEndedAllRepetitionsNotification
                                               object:self];
}
//------------------------------------------------------------------------------
-(void) removeAnimationHasEndedObserver{
    [[NSNotificationCenter defaultCenter] removeObserver:animEndedObserver
                                                    name:LHAnimationHasEndedNotification
                                                  object:self];
    animEndedObserver = nil;
}
//------------------------------------------------------------------------------
-(void) removeAnimationHasChangedFrameObserver{
    [[NSNotificationCenter defaultCenter] removeObserver:animChangedFrameObserver
                                                    name:LHAnimationFrameNotification
                                                  object:self];
    animChangedFrameObserver = nil;
}
//------------------------------------------------------------------------------
-(void) removeAnimationHasEndedAllRepetitionsObserver{
    [[NSNotificationCenter defaultCenter] removeObserver:animEndedAllRepObserver
                                                    name:LHAnimationHasEndedAllRepetitionsNotification
                                                  object:self];
    animEndedAllRepObserver = nil;
}
//------------------------------------------------------------------------------

//use this methods when you want to get notification about animations for all sprites
+(void) setGlobalAnimationHasEndedObserver:(id)observer selector:(SEL)selector{
    [[NSNotificationCenter defaultCenter] addObserver:observer
                                             selector:selector
                                                 name:LHAnimationHasEndedNotification
                                               object:nil];
}
//------------------------------------------------------------------------------
+(void) setGlobalAnimationHasChangedFrameObserver:(id)observer selector:(SEL)selector{
    [[NSNotificationCenter defaultCenter] addObserver:observer
                                             selector:selector
                                                 name:LHAnimationFrameNotification
                                               object:nil];
}
//------------------------------------------------------------------------------
+(void) setGlobalAnimationHasEndedAllRepertitionsObserver:(id)observer selector:(SEL)selector{
    [[NSNotificationCenter defaultCenter] addObserver:observer
                                             selector:selector
                                                 name:LHAnimationHasEndedAllRepetitionsNotification
                                               object:nil];
}
//------------------------------------------------------------------------------
+(void) removeGlobalAnimationHasEndedObserver:(id)observer{
    [[NSNotificationCenter defaultCenter] removeObserver:observer
                                                    name:LHAnimationHasEndedNotification
                                                  object:nil];
}
//------------------------------------------------------------------------------
+(void) removeGlobalAnimationHasChangedFrameObserver:(id)observer{
    [[NSNotificationCenter defaultCenter] removeObserver:observer
                                                    name:LHAnimationFrameNotification
                                                  object:nil];
}
//------------------------------------------------------------------------------
+(void) removeGlobalAnimationHasEndedAllRepetitionsObserver:(id)observer{
    [[NSNotificationCenter defaultCenter] removeObserver:observer
                                                    name:LHAnimationHasEndedAllRepetitionsNotification
                                                  object:nil];
}
//------------------------------------------------------------------------------
-(void) playAnimation{ if(animation) [animation play];}
//------------------------------------------------------------------------------
-(void) pauseAnimation{ if(animation)[animation setPaused:YES];}
//------------------------------------------------------------------------------
-(void) restartAnimation{ if(animation)[animation restart];}
//------------------------------------------------------------------------------
-(bool) isAnimationPaused{ if(!animation)return false;
    return [animation paused];
}
//------------------------------------------------------------------------------
-(void) stopAnimation{
    if(!animation)return;

    [animation setPaused:YES];
    [animation restoreFrame];

    [self removeAnimationHasChangedFrameObserver];
    [self removeAnimationHasEndedAllRepetitionsObserver];
    [self removeAnimationHasEndedObserver];
    #ifndef LH_ARC_ENABLED
    [animation release];
    #endif
    animation = nil;
}
//------------------------------------------------------------------------------
-(NSString*) animationName{ if(animation) return [animation uniqueName];
    return @"";
}
//------------------------------------------------------------------------------
-(NSString*) animationSHScene{ if(animation) return [animation shSceneName];
    return @"";
}
//------------------------------------------------------------------------------
-(int) numberOfFrames{ if(animation)return [animation numberOfFrames];    
    return -1;
}
//------------------------------------------------------------------------------
-(float) animationDelayPerUnit{
    if(animation){return [animation delayPerUnit];}
    return 0.0f;
}
-(void) setAnimationDelayPerUnit:(float)d{
    if(animation){ if(d < 0.0f) d = 0.0f; [animation setDelayPerUnit:d];}
}
//------------------------------------------------------------------------------
-(float)animationDuration{
    if(animation)return [animation totalTime];
    return 0.0f;
}
//------------------------------------------------------------------------------
-(void) setFrame:(int)frmNo{ if(animation)[animation setFrame:frmNo];}
//------------------------------------------------------------------------------
-(int) currentFrame{     
    if(animation) return [animation currentFrame];    
    return -1;
}
//------------------------------------------------------------------------------
-(void) nextFrame{ if(animation)[animation nextFrame];}
//------------------------------------------------------------------------------
-(void) prevFrame{ if(animation)[animation prevFrame];}
//------------------------------------------------------------------------------
-(void) nextFrameAndRepeat{ if(animation)[animation nextFrameAndRepeat];}
//------------------------------------------------------------------------------
-(void) prevFrameAndRepeat{ if(animation)[animation prevFrameAndRepeat];}
//------------------------------------------------------------------------------
-(bool) isAtLastFrame{ if(animation)return [animation isAtLastFrame];
    return false;
}
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
-(NSString*)userInfoClassName{
    if(userCustomInfo)
        return NSStringFromClass([userCustomInfo class]);
    return @"No Class";
}
//------------------------------------------------------------------------------
-(id)userInfo{
    return userCustomInfo;
}
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
#ifdef LH_USE_BOX2D
-(NSArray*) jointList{
    NSMutableArray* array = [NSMutableArray array];
    if(body != NULL){
        b2JointEdge* jtList = body->GetJointList();
        while (jtList) {
            LHJoint* lhJt = [LHJoint jointFromBox2dJoint:jtList->joint];
            if(lhJt != NULL)
                [array addObject:lhJt];
            jtList = jtList->next;
        }
    }
    return array;
}
//------------------------------------------------------------------------------
-(LHJoint*) jointWithUniqueName:(NSString*)name{
    if(name == nil) return nil;
    NSArray* jointList = [self jointList];
    for(LHJoint* jt in jointList){
        if([[jt uniqueName] isEqualToString:name]){
            return jt;
        }
    }
    return nil;
}
//------------------------------------------------------------------------------
-(bool) removeAllAttachedJoints{
    NSArray* list = [self jointList];
    if(list){
        for(LHJoint* jt in list){
            [jt removeSelf];
        }
        return true;
    }
    return false;
}
//------------------------------------------------------------------------------
-(bool) removeJoint:(LHJoint*)joint{
    NSMutableArray* list = (NSMutableArray*)[self jointList];
    if(list){
        for(LHJoint* jt in list){
            if(jt == joint){
                [jt removeSelf];
                return true;
            }
        }
    }    
    NSLog(@"WARNING: Trying to remove joint %@ from the sprite %@ but the joint does not belong to that sprite. Removal of joint was not performed.", [joint uniqueName], uniqueName);
    return false;
}
#endif
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
-(void) prepareMovementOnPathWithUniqueName:(NSString*)pathName{
     NSAssert(pathName!=nil, @"UniqueName must not be nil");

    [self stopPathMovement];
    
    NSArray* allLayers = [[LHSettings sharedInstance] allLHMainLayers];

    LHBezier* bezier = nil;
    for(LHLayer* layer in allLayers){
        bezier = [layer bezierWithUniqueName:pathName];
        if(bezier)
            break;
    }
    if(bezier){
        pathNode = [[LHPathNode alloc] initPathNodeWithPoints:[bezier pathPoints] 
                                                     onSprite:self];
        [pathNode setPaused:YES];
        
        if(pathDefaultName)
        {
            #ifndef LH_ARC_ENABLED
            [pathDefaultName release];
            #endif
        }
        
        pathDefaultName = [[NSString alloc] initWithString:pathName];
        [pathNode setFlipX:pathDefaultFlipX];
        [pathNode setFlipY:pathDefaultFlipY];
        [pathNode setIsCyclic:pathDefaultIsCyclic];
        [pathNode setRelativeMovement:pathDefaultRelativeMove];
        [pathNode setAxisOrientation:pathDefaultOrientation];
        [pathNode setRestartOtherEnd:pathDefaultRestartOtherEnd];
        [pathNode setSpeed:pathDefaultSpeed];
        [pathNode setStartAtEndPoint:pathDefaultStartPoint];
    }
}

-(NSString*) pathUniqueName{
    return pathDefaultName;
}


//use this methods when you want to get notification about animation on a per sprite basis
-(void) setPathMovementHasEndedObserver:(id)observer selector:(SEL)selector{
    pathEndedObserver = observer;
    [[NSNotificationCenter defaultCenter] addObserver:observer
                                             selector:selector
                                                 name:LHPathMovementHasEndedNotification
                                               object:self];
}
//------------------------------------------------------------------------------
-(void) setPathMovementHasChangedPointObserver:(id)observer selector:(SEL)selector{
    pathChangedPointObserver = observer;
    [[NSNotificationCenter defaultCenter] addObserver:observer
                                             selector:selector
                                                 name:LHPathMovementHasChangedPointNotification
                                               object:self];
}
//------------------------------------------------------------------------------
-(void) removePathMovementHasEndedObserver{
    [[NSNotificationCenter defaultCenter] removeObserver:pathEndedObserver
                                                    name:LHPathMovementHasEndedNotification
                                                  object:self];
    pathEndedObserver = nil;
}
//------------------------------------------------------------------------------
-(void) removePathMovementHasChangedPointObserver{
    [[NSNotificationCenter defaultCenter] removeObserver:pathChangedPointObserver
                                                    name:LHPathMovementHasChangedPointNotification
                                                  object:self];
    pathChangedPointObserver = nil;
}
//------------------------------------------------------------------------------

//use this methods when you want to get notification about animations for all sprites
+(void) setGlobalPathMovementHasEndedObserver:(id)observer selector:(SEL)selector{
    [[NSNotificationCenter defaultCenter] addObserver:observer
                                             selector:selector
                                                 name:LHPathMovementHasEndedNotification
                                               object:nil];
}
//------------------------------------------------------------------------------
+(void) setGlobalPathMovementHasChangedPointObserver:(id)observer selector:(SEL)selector{
    [[NSNotificationCenter defaultCenter] addObserver:observer
                                             selector:selector
                                                 name:LHPathMovementHasChangedPointNotification
                                               object:nil];
}
//------------------------------------------------------------------------------
+(void) removeGlobalPathMovementHasEndedObserver:(id)observer{
    [[NSNotificationCenter defaultCenter] removeObserver:observer
                                                    name:LHPathMovementHasEndedNotification
                                                  object:nil];
}
//------------------------------------------------------------------------------
+(void) removeGlobalPathMovementHasChangedPointObserver:(id)observer{
    [[NSNotificationCenter defaultCenter] removeObserver:observer
                                                    name:LHPathMovementHasChangedPointNotification
                                                  object:nil];
}
//------------------------------------------------------------------------------


-(void) startPathMovement{
    if(pathNode)[pathNode setPaused:NO];
}
-(void) pausePathMovement{
    if(pathNode)[pathNode setPaused:YES];
}
-(void) restartPathMovement{
    if(pathNode)[pathNode restart];
}
-(void) stopPathMovement{
    if(pathNode){
        
        [self removePathMovementHasChangedPointObserver];
        [self removePathMovementHasEndedObserver];
        #ifndef LH_ARC_ENABLED
        [pathNode release]; 
        #endif
        pathNode = nil;
    }
}
-(void) setPathMovementSpeed:(float)value{
    if(pathNode)[pathNode setSpeed:value];
}
-(float)pathMovementSpeed{
    if(pathNode)return [pathNode speed];
    return 0.0f;
}
-(void) setPathMovementStartPoint:(enum LH_PATH_MOVEMENT_START_POINT)point{
    if(!pathNode)return;
    [pathNode setStartAtEndPoint:(bool)point];
}
-(enum LH_PATH_MOVEMENT_START_POINT) pathMovementStartPoint{
    if(!pathNode)return  LH_PATH_INVALID_POINT;
    return (enum LH_PATH_MOVEMENT_START_POINT)[pathNode startAtEndPoint];
}
-(void) setPathMovementIsCyclic:(bool)cyclic{
    if(pathNode)[pathNode setIsCyclic:cyclic];
}
-(bool) pathMovementIsCyclic{
    if(!pathNode)return false;
    return [pathNode isCyclic];
}
-(void) setPathMovementRestartsAtOtherEnd:(bool)otherEnd{
    if(pathNode)[pathNode setRestartOtherEnd:otherEnd];
}
-(bool) pathMovementRestartsAtOtherEnd{
    if(!pathNode)return false;
    return [pathNode restartOtherEnd];
}
-(void) setPathMovementOrientation:(enum LH_PATH_MOVEMENT_ORIENTATION)point{
    if(pathNode)[pathNode setAxisOrientation:(int)point];
}
-(enum LH_PATH_MOVEMENT_ORIENTATION) pathMovementOrientation{
    if(!pathNode)return LH_INVALID_ORIENTATION;
    return (enum LH_PATH_MOVEMENT_ORIENTATION)[pathNode axisOrientation];
}
-(void) setPathMovementFlipXAtEnd:(bool)flip{
    if(pathNode)[pathNode setFlipX:flip];
}
-(bool) pathMovementFlipXAtEnd{
    if(!pathNode)return false;
    return [pathNode flipX];
}
-(void) setPathMovementFlipYAtEnd:(bool)flip{
    if(pathNode)[pathNode setFlipY:flip];    
}
-(bool) pathMovementFlipYAtEnd{
    if(!pathNode)return false;
    return [pathNode flipY];
}
-(void) setPathMovementRelative:(bool)rel{
    if(pathNode)[pathNode setRelativeMovement:rel];
}
-(bool) pathMovementRelative{
    if(!pathNode)return false;
    return [pathNode relativeMovement];
}

////////////////////////////////////////////////////////////////////////////////
-(bool)isTouchedAtPoint:(CGPoint)point{

#ifdef LH_USE_BOX2D
    if(body == NULL || !usePhysicsForTouches)
    {
#endif
        CGRect bbox = CGRectMake( 0.0f, 0.0f, self.contentSize.width, self.contentSize.height );
        bbox = CGRectApplyAffineTransform(bbox, [self nodeToWorldTransform] );
        return CGRectContainsPoint( bbox, point );

#ifdef LH_USE_BOX2D
    }
    else{
        b2Fixture* stFix = body->GetFixtureList();
        while(stFix != 0){
            if(stFix->TestPoint(b2Vec2(point.x/[[LHSettings sharedInstance] lhPtmRatio], 
                                       point.y/[[LHSettings sharedInstance] lhPtmRatio]))){
                return true;
            }
            stFix = stFix->GetNext();
        }
    }
    return false;
#endif
}
-(void)setUsePhysicsForTouches:(bool)val{
    usePhysicsForTouches = val;
}
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
-(void)registerTouchBeginObserver:(id)observer selector:(SEL)selector{
    [self registerTouchBeganObserver:observer selector:selector];
}
-(void)registerTouchBeganObserver:(id)observer selector:(SEL)selector{
//    [self removeTouchObserver];

    if(nil == touchBeginObserver)
    {
#if COCOS2D_VERSION >= 0x00020000
    #ifdef __CC_PLATFORM_IOS
            CCDirectorIOS *director = (CCDirectorIOS*) [CCDirector sharedDirector];
            CCTouchDispatcher *dispatcher = [director touchDispatcher];
            [dispatcher addTargetedDelegate:self
                                   priority:touchPriority
                            swallowsTouches:swallowTouches];
        
    #else //MAC
            CCEventDispatcher* dispatcher = [[CCDirector sharedDirector] eventDispatcher];
            [dispatcher addMouseDelegate:self priority:touchPriority];
    #endif
#else //cocos2d 1.0.1
    #ifdef __IPHONE_OS_VERSION_MAX_ALLOWED
            [[CCTouchDispatcher sharedDispatcher] addTargetedDelegate:self
                                                             priority:touchPriority
                                                      swallowsTouches:swallowTouches];
        
    #else //MAC//if defined(__MAC_OS_X_VERSION_MAX_ALLOWED)
            [[CCEventDispatcher sharedDispatcher] addMouseDelegate:self priority:touchPriority];
        
    #endif
#endif
            
    }
    
    if(nil == touchBeginObserver)
        touchBeginObserver = [LHObserverPair observerPair];
        
    touchBeginObserver.object = observer;
    touchBeginObserver.selector = selector;
#ifndef LH_ARC_ENABLED
    [touchBeginObserver retain];
#endif
}
//------------------------------------------------------------------------------
-(void)registerTouchMovedObserver:(id)observer selector:(SEL)selector{
    if(nil == touchMovedObserver)
        touchMovedObserver = [LHObserverPair observerPair];
    
    touchMovedObserver.object = observer;
    touchMovedObserver.selector = selector;
#ifndef LH_ARC_ENABLED
    [touchMovedObserver retain];
#endif
}
//------------------------------------------------------------------------------
-(void)registerTouchEndedObserver:(id)observer selector:(SEL)selector{
    if(nil == touchEndedObserver)
        touchEndedObserver = [LHObserverPair observerPair];
    
    touchEndedObserver.object = observer;
    touchEndedObserver.selector = selector;    
#ifndef LH_ARC_ENABLED
    [touchEndedObserver retain];
#endif
}
//------------------------------------------------------------------------------
-(void)removeTouchObserver
{
//    NSLog(@"REMOVE TOUCH OBSERVER");
    
#ifndef LH_ARC_ENABLED    
    if(touchBeginObserver)
        [touchBeginObserver release];
    if(touchMovedObserver)
        [touchMovedObserver release];
    if(touchEndedObserver)
        [touchEndedObserver release];
#endif

    touchBeginObserver = nil;
    touchMovedObserver = nil;
    touchEndedObserver = nil;
    
    [LevelHelperLoader removeTouchDispatcherFromObject:self];
    
    tagTouchBeginObserver = nil;
    tagTouchMovedObserver = nil;
    tagTouchEndedObserver = nil;
}
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
#ifdef __MAC_OS_X_VERSION_MAX_ALLOWED
//for left mouse events use the touch observers from above 
-(void)registerRightMouseDownObserver:(id)observer selector:(SEL)selector{
    if(nil == rightMouseDownObserver)
        rightMouseDownObserver = [LHObserverPair observerPair];
    
    rightMouseDownObserver.object = observer;
    rightMouseDownObserver.selector = selector;
#ifndef LH_ARC_ENABLED
    [rightMouseDownObserver retain];
#endif
}
//------------------------------------------------------------------------------
-(void)registerRightMouseDraggedObserver:(id)observer selector:(SEL)selector{
    if(nil == rightMouseDraggedObserver)
        rightMouseDraggedObserver = [LHObserverPair observerPair];
    
    rightMouseDraggedObserver.object = observer;
    rightMouseDraggedObserver.selector = selector;
#ifndef LH_ARC_ENABLED
    [rightMouseDraggedObserver retain];
#endif
}
//------------------------------------------------------------------------------
-(void)registerRightMouseUpObserver:(id)observer selector:(SEL)selector{
    if(nil == rightMouseUpObserver)
        rightMouseUpObserver = [LHObserverPair observerPair];
    
    rightMouseUpObserver.object = observer;
    rightMouseUpObserver.selector = selector;
#ifndef LH_ARC_ENABLED
    [rightMouseUpObserver retain];
#endif    
}
#endif

//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
#ifdef __IPHONE_OS_VERSION_MAX_ALLOWED
-(CGPoint)convertedPoint:(CGPoint)touchPoint{
    touchPoint=  [[CCDirector sharedDirector] convertToGL:touchPoint];    
    
    CCNode* prevParent = nil;
    CCNode* layerParent = self.parent;
    
    while(layerParent){
        if(layerParent.parent){
            prevParent = layerParent;
            layerParent = layerParent.parent;
        }
        else{
            layerParent = prevParent;
            break;
        }
    }
//    if(layerParent){
//        touchPoint.x -= layerParent.position.x;
//        touchPoint.y -= layerParent.position.y;
//    }
    if(layerParent){
       return CGPointApplyAffineTransform(touchPoint,layerParent.worldToNodeTransform);
        
    }
    return touchPoint;
}
//------------------------------------------------------------------------------
- (BOOL)ccTouchBegan:(UITouch *)touch withEvent:(UIEvent *)event{
    
    if(touchesDisabled)
        return false;
    
    if(self == nil)
        return NO;

    if(nil == touchBeginObserver && nil == tagTouchBeginObserver)
        return false;
    
    CGPoint touchPoint = [touch locationInView:[touch view]];
    touchPoint = [self convertedPoint:touchPoint];
    
    if([self isTouchedAtPoint:touchPoint])
    {
        LHTouchInfo* info = [LHTouchInfo touchInfo];
        info.relativePoint = CGPointMake(touchPoint.x - self.position.x,
                                         touchPoint.y - self.position.y);
        info.glPoint = touchPoint;
        info.event = event;
        info.touch = touch;
        info.sprite = self;
        info.delta = CGPointZero;

        [LHObserverPair performObserverPair:touchBeginObserver object:info];
        [LHObserverPair performObserverPair:tagTouchBeginObserver object:info]; 
        return true;
    }
    return false;
}
//------------------------------------------------------------------------------
- (void)ccTouchMoved:(UITouch *)touch withEvent:(UIEvent *)event{  
    
    if(touchesDisabled)return;
    
    CGPoint touchPoint = [touch locationInView:[touch view]];
    touchPoint = [self convertedPoint:touchPoint];
        
    CGPoint prevLocation = [touch previousLocationInView:[touch view]];
    prevLocation = [self convertedPoint:prevLocation];

    LHTouchInfo* info = [LHTouchInfo touchInfo];
    info.relativePoint = CGPointMake(touchPoint.x - self.position.x,
                                     touchPoint.y - self.position.y);
    info.glPoint = touchPoint;
    info.event = event;
    info.touch = touch;
    info.sprite = self;
    info.delta = CGPointMake(touchPoint.x - prevLocation.x,
                             touchPoint.y - prevLocation.y);

    [LHObserverPair performObserverPair:touchMovedObserver object:info];
    [LHObserverPair performObserverPair:tagTouchMovedObserver object:info]; 
}
//------------------------------------------------------------------------------
- (void)ccTouchEnded:(UITouch *)touch withEvent:(UIEvent *)event{

    if(touchesDisabled)
        return;
    
    CGPoint touchPoint = [touch locationInView:[touch view]];
    touchPoint= [self convertedPoint:touchPoint];

    CGPoint prevLocation = [touch previousLocationInView:[touch view]];
    prevLocation = [self convertedPoint:prevLocation];

    LHTouchInfo* info = [LHTouchInfo touchInfo];
    info.relativePoint = CGPointMake(touchPoint.x - self.position.x,
                                     touchPoint.y - self.position.y);
    info.glPoint = touchPoint;
    info.event = event;
    info.touch = touch;
    info.sprite = self;
    info.delta = CGPointMake(touchPoint.x - prevLocation.x,
                             touchPoint.y - prevLocation.y);

    [LHObserverPair performObserverPair:touchEndedObserver object:info];
    [LHObserverPair performObserverPair:tagTouchEndedObserver object:info]; 
}

- (void)ccTouchCancelled:(UITouch *)touch withEvent:(UIEvent *)event{
#pragma unused (touch)
#pragma unused (event)    
}
//------------------------------------------------------------------------------
#elif defined(__MAC_OS_X_VERSION_MAX_ALLOWED)
//------------------------------------------------------------------------------
-(CGPoint)convertedEvent:(NSEvent*)event{
    CGPoint touchPoint = [(CCDirectorMac*)[CCDirector sharedDirector] convertEventToGL:event];
    
    CCNode* prevParent = nil;
    CCNode* layerParent = self.parent;
    
    while(layerParent){
        if(layerParent.parent){
            prevParent = layerParent;
            layerParent = layerParent.parent;
        }
        else{
            layerParent = prevParent;
            break;
        }
    }
    
    if(layerParent){
        touchPoint.x -= layerParent.position.x;
        touchPoint.y -= layerParent.position.y;
    }
    return touchPoint;
}
//------------------------------------------------------------------------------
-(BOOL) ccMouseDown:(NSEvent*)event{   
    
    if(touchesDisabled)
        return false;
    
    CGPoint touchPoint = [self convertedEvent:event];
        
    if([self isTouchedAtPoint:touchPoint])
    {
        mouseDownStarted = true;
        LHTouchInfo* info = [LHTouchInfo touchInfo];
        info.relativePoint = CGPointMake(touchPoint.x - self.position.x,
                                         touchPoint.y - self.position.y);
        info.glPoint = touchPoint;
        info.event = event;
        info.touch = nil;
        info.sprite = self;
        info.delta = CGPointZero;
        
        [LHObserverPair performObserverPair:touchBeginObserver object:info];
        [LHObserverPair performObserverPair:tagTouchBeginObserver object:info]; 

        return swallowTouches;
    }
    return NO;
}
//------------------------------------------------------------------------------
-(BOOL) ccMouseDragged:(NSEvent*)event{
    
    if(touchesDisabled)
        return false;
    
    if(!mouseDownStarted)
        return NO;

    CGPoint touchPoint = [self convertedEvent:event];
            
    LHTouchInfo* info = [LHTouchInfo touchInfo];
    info.relativePoint = CGPointMake(touchPoint.x - self.position.x,
                                     touchPoint.y - self.position.y);
    info.glPoint = touchPoint;
    info.event = event;
    info.touch = nil;
    info.sprite = self;
    info.delta = CGPointMake([event deltaX], [event deltaY]);
    
    [LHObserverPair performObserverPair:touchMovedObserver object:info];
    [LHObserverPair performObserverPair:tagTouchMovedObserver object:info]; 

    return swallowTouches;//avoid propagation
}
//------------------------------------------------------------------------------
-(BOOL) ccMouseUp:(NSEvent*)event{
    
    if(touchesDisabled)
        return false;
    
    if(!mouseDownStarted)
        return NO;

    CGPoint touchPoint = [self convertedEvent:event];
        
    mouseDownStarted = false;
    LHTouchInfo* info = [LHTouchInfo touchInfo];
    info.relativePoint = CGPointMake(touchPoint.x - self.position.x,
                                     touchPoint.y - self.position.y);
    info.glPoint = touchPoint;
    info.event = event;
    info.touch = nil;
    info.sprite = self;
    info.delta = CGPointMake([event deltaX], [event deltaY]);
    
    [LHObserverPair performObserverPair:touchEndedObserver object:info];
    [LHObserverPair performObserverPair:tagTouchEndedObserver object:info]; 

    return swallowTouches;//avoid propagation
}
//------------------------------------------------------------------------------
-(BOOL) ccRightMouseDown:(NSEvent*)event{
    
    if(touchesDisabled)
        return false;
    
    CGPoint touchPoint = [self convertedEvent:event];
    
    if([self isTouchedAtPoint:touchPoint])
    {
        r_mouseDownStarted = true;
        LHTouchInfo* info = [LHTouchInfo touchInfo];
        info.relativePoint = CGPointMake(touchPoint.x - self.position.x,
                                         touchPoint.y - self.position.y);
        info.glPoint = touchPoint;
        info.event = event;
        info.touch = nil;
        info.sprite = self;
        info.delta = CGPointZero;
        
        [LHObserverPair performObserverPair:rightMouseDownObserver object:info];
        [LHObserverPair performObserverPair:tagRightMouseDownObserver object:info]; 
        
        return swallowTouches;
    }
    return NO;
}
//------------------------------------------------------------------------------
-(BOOL) ccRightMouseDragged:(NSEvent*)event{
    
    if(touchesDisabled)
        return false;
    
    if(!r_mouseDownStarted)
        return NO;

    CGPoint touchPoint = [self convertedEvent:event];
        
    LHTouchInfo* info = [LHTouchInfo touchInfo];
    info.relativePoint = CGPointMake(touchPoint.x - self.position.x,
                                     touchPoint.y - self.position.y);
    info.glPoint = touchPoint;
    info.event = event;
    info.touch = nil;
    info.sprite = self;
    info.delta = CGPointMake([event deltaX], [event deltaY]);
    
    [LHObserverPair performObserverPair:rightMouseDraggedObserver object:info];
    [LHObserverPair performObserverPair:tagRightMouseDraggedObserver object:info]; 
    
    return swallowTouches;//avoid propagation
}
//------------------------------------------------------------------------------
-(BOOL) ccRightMouseUp:(NSEvent*)event{
    
    if(touchesDisabled)
        return false;
    
    if(!r_mouseDownStarted)
        return NO;

    CGPoint touchPoint = [self convertedEvent:event];
        
    r_mouseDownStarted = false;
    LHTouchInfo* info = [LHTouchInfo touchInfo];
    info.relativePoint = CGPointMake(touchPoint.x - self.position.x,
                                     touchPoint.y - self.position.y);
    info.glPoint = touchPoint;
    info.event = event;
    info.touch = nil;
    info.sprite = self;
    info.delta = CGPointMake([event deltaX], [event deltaY]);
    
    [LHObserverPair performObserverPair:rightMouseUpObserver object:info];
    [LHObserverPair performObserverPair:tagRightMouseUpObserver object:info]; 
    
    return swallowTouches;//avoid propagation
}

#endif

////////////////////////////////////////////////////////////////////////////////
#ifdef LH_USE_BOX2D
+(NSString*) uniqueNameForBody:(b2Body*)body{
    
#ifndef LH_ARC_ENABLED
    id spr = (id)body->GetUserData();
#else
    id spr = (__bridge id)body->GetUserData();
#endif
    
    if([LHSprite isLHSprite:spr])
        return [spr uniqueName];
    
    if([LHBezier isLHBezier:spr])
        return [spr uniqueName];
    
    return nil;
}
//------------------------------------------------------------------------------
+(LHSprite*) spriteForBody:(b2Body*)body
{
    if(0 == body)
        return nil;
#ifndef LH_ARC_ENABLED 
    id spr = (id)body->GetUserData();
#else
    id spr = (__bridge id)body->GetUserData();
#endif
    
    if([LHSprite isLHSprite:spr])
        return spr;
    
    return nil;    
}
//------------------------------------------------------------------------------
+(int) tagForBody:(b2Body*)body{
    if(0 != body){
        #ifndef LH_ARC_ENABLED 
        CCNode* spr = (CCNode*)body->GetUserData();
        #else
        CCNode* spr = (__bridge CCNode*)body->GetUserData();
        #endif
        if(nil != spr){
            return (int)[spr tag];
        }
    }
    return -1;
}
#endif
//------------------------------------------------------------------------------
+(bool) isLHSprite:(id)object{
    if([object isKindOfClass:[LHSprite class]]){
        return true;
    }
    return false;
}
////////////////////////////////////////////////////////////////////////////////
- (NSComparisonResult)sortAscending:(LHSprite *)other{

    if(nil == other)
        return NSOrderedSame;
    
    return [uniqueName compare:[other uniqueName]];
}
//------------------------------------------------------------------------------
- (NSComparisonResult)sortDescending:(LHSprite *)other
{		
    if(nil == other)
        return NSOrderedSame;

    NSComparisonResult result = [uniqueName compare:[other uniqueName]];
    
    if(result == NSOrderedDescending)
        return NSOrderedAscending;
    else if(result == NSOrderedAscending)
        return NSOrderedDescending;
    
    return NSOrderedSame;           
}
//------------------------------------------------------------------------------
#ifdef LH_USE_BOX2D
-(void)setCollisionFilterCategory:(int)category{
    if(body == nil)
        return;
    
    b2Fixture* curFix = body->GetFixtureList();
    while (curFix) {
        
        b2Filter curFilter = curFix->GetFilterData();

        b2Filter filter;
        filter.categoryBits = (uint16)category;
        filter.maskBits     = curFilter.maskBits;
        filter.groupIndex   = curFilter.groupIndex;

        curFix->SetFilterData(filter);        
        curFix = curFix->GetNext();
    }
}
-(void)setCollisionFilterMask:(int)mask{
    if(body == nil)
        return;

    b2Fixture* curFix = body->GetFixtureList();
    while (curFix) {
        
        b2Filter curFilter = curFix->GetFilterData();
        
        b2Filter filter;
        filter.categoryBits = curFilter.categoryBits;
        filter.maskBits     = (uint16)mask;
        filter.groupIndex   = curFilter.groupIndex;
        
        curFix->SetFilterData(filter);        
        curFix = curFix->GetNext();
    }
}
-(void)setCollisionFilterGroup:(int)group{
    if(body == nil)
        return;
    b2Fixture* curFix = body->GetFixtureList();
    while (curFix) {
        
        b2Filter curFilter = curFix->GetFilterData();
        
        b2Filter filter;
        filter.categoryBits = curFilter.categoryBits;
        filter.maskBits     = curFilter.maskBits;
        filter.groupIndex   = (int16)group;
        
        curFix->SetFilterData(filter);        
        curFix = curFix->GetNext();
    }
}

//TYPE CONVERSION
//------------------------------------------------------------------------------
-(void)makeDynamic{
    
    if(body == nil)
    {
        [self createBodyFromDefaultValuesWithType:b2_dynamicBody];
        [self createFixturesFromInfoOnBody];
        return;
    }
    
    body->SetType(b2_dynamicBody);    
}
-(void)makeStatic{
    if(body == nil){
        [self createBodyFromDefaultValuesWithType:b2_staticBody];
        [self createFixturesFromInfoOnBody];
        return;
    }
    
    body->SetType(b2_staticBody);
}
-(void)makeKinematic{
    if(body == nil)
    {
        [self createBodyFromDefaultValuesWithType:b2_kinematicBody];
        [self createFixturesFromInfoOnBody];
        return;
    }

    body->SetType(b2_kinematicBody);
}
-(void)makeNoPhysics{
    if(body == nil)
        return;
    
    [self removeBodyFromWorld];
}

-(void)setSensor:(bool)val fixtureWithName:(NSString*)fixName{
    if(body == nil)return;
    
    b2Fixture* fix = body->GetFixtureList();
    
    while (fix) {
#ifndef LH_ARC_ENABLED
        LHFixture* lhFix = (LHFixture*)(fix->GetUserData());
#else
        LHFixture* lhFix = (__bridge LHFixture*)(fix->GetUserData());
#endif
        if([LHFixture isLHFixture:lhFix])
        {
            if([[lhFix fixtureName] isEqualToString:fixName]){
                fix->SetSensor(val);
                return;
            }
        }
        fix = fix->GetNext();
    }
}

-(void)setSensor:(bool)val fixturesWithID:(int)fixID{
    if(body == nil)return;
    
    b2Fixture* fix = body->GetFixtureList();
    
    while (fix) {
        
#ifndef LH_ARC_ENABLED
        LHFixture* lhFix = (LHFixture*)(fix->GetUserData());
#else
        LHFixture* lhFix = (__bridge LHFixture*)(fix->GetUserData());
#endif

        if([LHFixture isLHFixture:lhFix])
        {
            if([lhFix fixtureID] == fixID){
                fix->SetSensor(val);
            }
        }
        fix = fix->GetNext();
    }
}

-(void)setSensor:(bool)val{
    if(body == nil)return;
    b2Fixture* fix = body->GetFixtureList();
    while (fix) {
        fix->SetSensor(val);
        fix = fix->GetNext();
    }
}

-(bool)hasContacts{
    if(body == nil)
        return false;
    
    b2ContactEdge* edge = body->GetContactList();
    if(NULL != edge){
        return true;
    }
    return false;
}

-(NSArray*)contactSprites{

    if(body == nil)
        return NULL;
    
    b2ContactEdge* edge = body->GetContactList();
    if(NULL == edge){
        return NULL;
    }
    
    NSMutableArray* array = [NSMutableArray array];
    
    while (edge != NULL) {
        
        b2Body* contact_body = edge->other;
        
        if(contact_body){
            
            LHSprite* spr = [LHSprite spriteForBody:contact_body];
            if(spr){
                [array addObject:spr];
            }
        }
        edge = edge->next;
    }
    
    return array;
}

-(NSArray*)contactBeziers{
    
    if(body == nil)
        return NULL;
    
    b2ContactEdge* edge = body->GetContactList();
    if(NULL == edge){
        return NULL;
    }
    
    NSMutableArray* array = [NSMutableArray array];
    
    while (edge != NULL) {
        
        b2Body* contact_body = edge->other;
        
        if(contact_body){
            
            LHBezier* bez = [LHBezier bezierForBody:contact_body];
            if(bez){
                [array addObject:bez];
            }
        }
        edge = edge->next;
    }
    
    return array;
}
//------------------------------------------------------------------------------
#endif
@end
