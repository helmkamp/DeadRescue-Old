//  This file was generated by LevelHelper
//  http://www.levelhelper.org
//
//  LevelHelperLoader.mm
//  Created by Bogdan Vladu
//  Copyright 2011 Bogdan Vladu. All rights reserved.
////////////////////////////////////////////////////////////////////////////////
//
//  This software is provided 'as-is', without any express or implied
//  warranty.  In no event will the authors be held liable for any damages
//  arising from the use of this software.
//  Permission is granted to anyone to use this software for any purpose,
//  including commercial applications, and to alter it and redistribute it
//  freely, subject to the following restrictions:
//  The origin of this software must not be misrepresented; you must not
//  claim that you wrote the original software. If you use this software
//  in a product, an acknowledgment in the product documentation would be
//  appreciated but is not required.
//  Altered source versions must be plainly marked as such, and must not be
//  misrepresented as being the original software.
//  This notice may not be removed or altered from any source distribution.
//  By "software" the author refers to this code file and not the application
//  that was used to generate this file.
//
////////////////////////////////////////////////////////////////////////////////
#import "LHBezier.h"
#import "LevelHelperLoader.h"
#import "LHTouchMgr.h"
#import "LHPathNode.h"
#import "LHSettings.h"
#import "LHSprite.h"
#import "LHLayer.h"
#import <Availability.h>
#import "LHCustomClasses.h"
#import "LHDictionaryExt.h"

#ifdef __IPHONE_OS_VERSION_MAX_ALLOWED
#import <OpenGLES/EAGL.h>
#elif defined(__MAC_OS_X_VERSION_MAX_ALLOWED)
#import <OpenGL/OpenGL.h>
#endif

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
@interface LHBezier (Private)
-(void) setupTileShapePoints: (NSArray *) points;
-(void) setupLinePoints:(NSArray*)points;
-(void) setupTileShapeTexCoordinates;
@end
////////////////////////////////////////////////////////////////////////////////
@implementation LHBezier
@synthesize isClosed;
@synthesize isTile;
@synthesize isVisible;
@synthesize isLine;
@synthesize swallowTouches;
////////////////////////////////////////////////////////////////////////////////
-(void) setupTileShapePoints: (NSArray *) points {
    
    if (tile_points)
        free(tile_points);
    if (tile_texCoords)
        free(tile_texCoords);
    if(tile_colors)
        free(tile_colors);
    
    //LH sends the points triangulated
    
    tile_pointCount = [points count];
    tile_points = (CGPoint *) malloc(sizeof(CGPoint) * tile_pointCount);
    tile_texCoords = (CGPoint *) malloc(sizeof(CGPoint) * tile_pointCount);
    tile_colors = (ccColor4F *) malloc(sizeof(ccColor4F) * tile_pointCount);
    
    int i = 0;
    for(NSValue* value in points){
        
        CGPoint pt = LHPointFromValue(value);
        
#if COCOS2D_VERSION >= 0x00020000
        tile_points[i] = pt;
#else
        tile_points[i].x = pt.x*CC_CONTENT_SCALE_FACTOR();;
        tile_points[i].y = pt.y*CC_CONTENT_SCALE_FACTOR();;
#endif
        
        tile_colors[i] = ccc4f(color.origin.x,
                               color.origin.y,
                               color.size.width,
                               opacity);
        
        ++i;
    }
    [self setupTileShapeTexCoordinates];
}

-(void)setupLinePoints:(NSArray*)points{
    
    if(line_points)
        free(line_points);
    if(line_colors)
        free(line_colors);
    
    line_pointCount = [points count];
    line_points = (CGPoint *) malloc(sizeof(CGPoint) * line_pointCount);
    line_colors = (ccColor4F *) malloc(sizeof(ccColor4F) * line_pointCount);
    
    int i = 0;
    for(NSValue* value in points){
        
        CGPoint pt = LHPointFromValue(value);
        
#if COCOS2D_VERSION >= 0x00020000
        line_points[i] = pt;
#else
        line_points[i].x = pt.x*CC_CONTENT_SCALE_FACTOR();;
        line_points[i].y = pt.y*CC_CONTENT_SCALE_FACTOR();;
#endif
        
        line_colors[i] = ccc4f(lineColor.origin.x,
                               lineColor.origin.y,
                               lineColor.size.width,
                               opacity);
        
        ++i;
    }
}

-(void) setupTileShapeTexCoordinates{
    for(int i = 0; i< tile_pointCount; ++i){
        CGPoint pt = tile_points[i];
        tile_texCoords[i].x = pt.x/(tile_texture.pixelsWide/CC_CONTENT_SCALE_FACTOR());
        tile_texCoords[i].y = 1.0f -  pt.y/(tile_texture.pixelsHigh/CC_CONTENT_SCALE_FACTOR());
    }
}

#if COCOS2D_VERSION >= 0x00020000
-(void) draw{
    
    if(!isVisible)
        return;
    
    
    if(tile_texture == nil || (drawBorder && tile_texture))
    {
        float oldLineWidth = 1.0f;
        glGetFloatv(GL_LINE_WIDTH, &oldLineWidth);
        glLineWidth(lineWidth*CC_CONTENT_SCALE_FACTOR());
        
        
        ccGLEnable( glServerState_ );
        [lineShaderProgram use];
        
#if COCOS2D_VERSION >= 0x00020100
        [lineShaderProgram setUniformsForBuiltins];
#else
        [lineShaderProgram setUniformForModelViewProjectionMatrix];
#endif
        ccGLEnableVertexAttribs( kCCVertexAttribFlag_Position | kCCVertexAttribFlag_Color);
        
        glVertexAttribPointer(kCCVertexAttrib_Position, 2, GL_FLOAT, GL_FALSE, 0, line_points);
        glVertexAttribPointer(kCCVertexAttrib_Color, 4, GL_FLOAT, GL_TRUE, 0, line_colors);
        glDrawArrays(GL_LINES, 0, line_pointCount);
        
        glLineWidth(oldLineWidth);
    }
    
    CC_NODE_DRAW_SETUP();
    
    if(tile_texture){
        ccGLBindTexture2D(tile_texture.name );
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
        ccGLBlendFunc( tile_blendFunc.src, tile_blendFunc.dst);
	}
    ccGLEnableVertexAttribs( kCCVertexAttribFlag_Position | kCCVertexAttribFlag_TexCoords | kCCVertexAttribFlag_Color);
    
    glVertexAttribPointer(kCCVertexAttrib_Position, 2, GL_FLOAT, GL_FALSE, 0, tile_points);
    glVertexAttribPointer(kCCVertexAttrib_TexCoords, 2, GL_FLOAT, GL_FALSE, 0, tile_texCoords);
    glVertexAttribPointer(kCCVertexAttrib_Color, 4, GL_FLOAT, GL_TRUE, 0, tile_colors);
    
    glDrawArrays(GL_TRIANGLES, 0, tile_pointCount);
    
    CC_INCREMENT_GL_DRAWS(1);
    CHECK_GL_ERROR_DEBUG();
}
#else
-(void) draw{
    
    if(!isVisible)
        return;
    
    
    if(tile_texture == nil || (drawBorder && tile_texture))
    {
        glDisable(GL_TEXTURE_2D);
        float oldLineWidth = 1.0f;
        glGetFloatv(GL_LINE_WIDTH, &oldLineWidth);
        glLineWidth(lineWidth*CC_CONTENT_SCALE_FACTOR());
        
        glVertexPointer(2, GL_FLOAT, 0, line_points);
        glColorPointer(4, GL_FLOAT, 0, line_colors);
        glDrawArrays(GL_LINES, 0, line_pointCount);
        
        glLineWidth(oldLineWidth);
        glEnable(GL_TEXTURE_2D);
    }
    
    
    
    
    // we have a pointer to vertex points so enable client state
    glBindTexture(GL_TEXTURE_2D, tile_texture.name);
    
    glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_DECAL);
    
    glVertexPointer(2, GL_FLOAT, 0, tile_points);
    glTexCoordPointer(2, GL_FLOAT, 0, tile_texCoords);
    glColorPointer(4, GL_FLOAT, 0, tile_colors);
    
    glDrawArrays(GL_TRIANGLES, 0, tile_pointCount);
    glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);
    
    //Restore texture matrix and switch back to modelview matrix
    glEnableClientState(GL_COLOR_ARRAY);
}
#endif


-(void) updateBlendFunc {
	if( !tile_texture || ! [tile_texture hasPremultipliedAlpha] ) {
		tile_blendFunc.src = GL_SRC_ALPHA;
		tile_blendFunc.dst = GL_ONE_MINUS_SRC_ALPHA;
	} else {
		tile_blendFunc.src = CC_BLEND_SRC;
		tile_blendFunc.dst = CC_BLEND_DST;
	}
}

-(void) setBlendFunction:(ccBlendFunc)blendFuncIn {
	tile_blendFunc = blendFuncIn;
}

-(ccBlendFunc) blendFunction {
	return tile_blendFunc;
}

-(void) setTexture:(CCTexture2D *) texture2D {
	
	// accept texture==nil as argument
    if(texture2D == nil)return;

#ifndef LH_ARC_ENABLED
	[tile_texture release];
#endif
    
    tile_texture = nil;

#ifndef LH_ARC_ENABLED
	tile_texture = [texture2D retain];
#else
    tile_texture = texture2D;
#endif
    
	ccTexParams texParams = { GL_NEAREST, GL_NEAREST, GL_REPEAT, GL_REPEAT };
	[tile_texture setTexParameters: &texParams];
	
	[self updateBlendFunc];
	[self setupTileShapeTexCoordinates];
}

-(CCTexture2D *) texture {
	return tile_texture;
}


-(void) dealloc{
    
    //    NSLog(@"LHBezier Dealloc %@", uniqueName);
    
    [LevelHelperLoader removeTouchDispatcherFromObject:self];
    
    [self removeBodyFromWorld];
    
    free(tile_points);
	free(tile_texCoords);
    free(tile_colors);
    
    free(line_points);
	free(line_colors);
    
#ifndef LH_ARC_ENABLED
    
    [tile_texture release];
    if(userCustomInfo){
        [userCustomInfo release];
        userCustomInfo = nil;
    }
    
    if(touchBeginObserver)
        [touchBeginObserver release];
    if(touchBeginObserver)
        [touchMovedObserver release];
    if(touchBeginObserver)
        [touchEndedObserver release];
    
	[uniqueName release];
	[pathPoints release];
    
	[super dealloc];
#endif
    
    tile_texture = nil;
}

-(void)removeBodyFromWorld{
#ifdef LH_USE_BOX2D
	if(NULL != body){
		b2World* _world = body->GetWorld();
		if(0 != _world){
			_world->DestroyBody(body);
			body = NULL;
		}
	}
#endif
}

-(LevelHelperLoader*)parentLoader{
    
    CCNode* layerParent = self.parent;
    
    while (layerParent && ![layerParent isKindOfClass:[LHLayer class]])
    {
        layerParent = layerParent.parent;
    }
    
    if(layerParent && [layerParent isKindOfClass:[LHLayer class]]) {
        return [(LHLayer*)layerParent parentLoader];
    }
    return nil;
}


-(void)removeSelf{
    
#ifdef LH_USE_BOX2D
    if(body){
        if(body->GetWorld()->IsLocked()){
            [[LHSettings sharedInstance] markBezierForRemoval:self];
            return;
        }
    }
#endif
    
    [self removeFromParentAndCleanup:YES];
}

-(void) onExit{
    //    NSLog(@"LHBEZIER %@ onExit", uniqueName);
    [LevelHelperLoader removeTouchDispatcherFromObject:self];
}

////////////////////////////////////////////////////////////////////////////////
+(CGPoint) pointOnCurve:(CGPoint) p1 p2:(CGPoint)p2 p3:(CGPoint)p3 p4:(CGPoint)p4 t:(float)t
{
	float var1, var2, var3;
    CGPoint vPoint = {0.0f, 0.0f};
    
    var1 = 1 - t;
    var2 = var1 * var1 * var1;
    var3 = t * t * t;
    vPoint.x = var2*p1.x + 3*t*var1*var1*p2.x + 3*t*t*var1*p3.x + var3*p4.x;
    vPoint.y = var2*p1.y + 3*t*var1*var1*p2.y + 3*t*t*var1*p3.y + var3*p4.y;
    return(vPoint);
}
////////////////////////////////////////////////////////////////////////////////
-(void) initTileAndPathVerticesFromDictionary:(NSDictionary*)dictionary
                                 tileVertices:(NSArray*)fixtures
{
    NSMutableArray* points = [NSMutableArray array];
 	for(NSArray* fix in fixtures){
		for(NSString* pt in fix){
			CGPoint point = LHPointFromString(pt);
            point = [[LHSettings sharedInstance] transformedPointToCocos2d:point];
            [points addObject:LHValueWithCGPoint(point)];
		}
	}
    [self setupTileShapePoints:points];
	
    int i = 0;
	
    pathPoints = [[NSMutableArray alloc] init];
    
    NSMutableArray* linepoints = [NSMutableArray array];
	if(isVisible)
	{
		NSArray* curvesInShape = [dictionary objectForKey:@"Curves"];
		
		int MAX_STEPS = 25;
		
		for(NSDictionary* curvDict in curvesInShape)
		{
			CGPoint endCtrlPt   = [curvDict pointForKey:@"EndControlPoint"];
			CGPoint startCtrlPt = [curvDict pointForKey:@"StartControlPoint"];
			CGPoint endPt       = [curvDict pointForKey:@"EndPoint"];
			CGPoint startPt     = [curvDict pointForKey:@"StartPoint"];
            
			if(!isLine)
			{
				CGPoint prevPoint;
				bool firstPt = true;
				
				for(float t = 0; t <= (1 + (1.0f / MAX_STEPS)); t += 1.0f / MAX_STEPS)
				{
					CGPoint vPoint = [LHBezier pointOnCurve:startPt
                                                         p2:startCtrlPt
                                                         p3:endCtrlPt
                                                         p4:endPt
                                                          t:t];
					
                    CGPoint curPoint = [[LHSettings sharedInstance] transformedPointToCocos2d:vPoint];
                    [pathPoints addObject:LHValueWithCGPoint(curPoint)];
                    
					if(!firstPt)
					{
                        
                        CGPoint pt1 = [[LHSettings sharedInstance] transformedPointToCocos2d:prevPoint];
                        CGPoint pt2 = [[LHSettings sharedInstance] transformedPointToCocos2d:vPoint];
                        
						[linepoints addObject:LHValueWithCGPoint(pt1)];
						[linepoints addObject:LHValueWithCGPoint(pt2)];
					}
					prevPoint = vPoint;
					firstPt = false;
				}
			}
			else
			{
                CGPoint pos1 = [[LHSettings sharedInstance] transformedPointToCocos2d:startPt];
                CGPoint pos2 = [[LHSettings sharedInstance] transformedPointToCocos2d:endPt];
                
				[linepoints addObject:LHValueWithCGPoint(pos1)];
				[linepoints addObject:LHValueWithCGPoint(pos2)];
				
                
                [pathPoints addObject:LHValueWithCGPoint(pos1)];
                if(i == (int)[curvesInShape count]-1){
                    [pathPoints addObject:LHValueWithCGPoint(pos2)];
                }
                ++i;
			}
		}
	}
    [self setupLinePoints:linepoints];
}
////////////////////////////////////////////////////////////////////////////////
#ifdef LH_USE_BOX2D
-(void) createBodyFromDictionary:(NSDictionary*)dictionary
                     physicWorld:(b2World*)world
{
	b2BodyDef bodyDef;
	
	int bodyType = [dictionary intForKey:@"Type"];
	if(bodyType > 2)
        return;
    
	bodyDef.type = (b2BodyType)bodyType;
    
	bodyDef.position.Set(0.0f, 0.0f);
	bodyDef.angle = 0.0f;
	
#ifndef LH_ARC_ENABLED
	bodyDef.userData = self;
#else
    bodyDef.userData = (__bridge void*)self;
#endif
	
	body = world->CreateBody(&bodyDef);
	float ptm = [[LHSettings sharedInstance] lhPtmRatio];
    
    
    NSArray* fixtures = [dictionary objectForKey:@"TileVertices"];
 	for(NSArray* fix in fixtures)
    {
        int size = (int)[fix count];
        b2Vec2 *verts = new b2Vec2[size];
        int i = 0;
        
        for(int j = (int)[fix count]-1; j >=0; --j)
        {
            CGPoint point = LHPointFromString([fix objectAtIndex:j]);
            point = [[LHSettings sharedInstance] transformedPointToCocos2d:point];
            
            verts[i].x = point.x/ptm;
            verts[i].y = point.y/ptm;
            ++i;
        }
        
        b2PolygonShape shape;
        shape.Set(verts, size);
        
        b2FixtureDef fixture;
        
        fixture.density = [dictionary floatForKey:@"Density"];
		fixture.friction = [dictionary floatForKey:@"Friction"];
		fixture.restitution = [dictionary floatForKey:@"Restitution"];
		
		fixture.filter.categoryBits = (uint16)[dictionary intForKey:@"Category"];
		fixture.filter.maskBits = (uint16)[dictionary intForKey:@"Mask"];
		fixture.filter.groupIndex = (int16)[dictionary intForKey:@"Group"];
		
		fixture.isSensor = [dictionary boolForKey:@"IsSensor"];
        
        fixture.shape = &shape;
        body->CreateFixture(&fixture);
        delete[] verts;
	}
    
    
    //we test for the version of box2d here
#ifdef B2_CHAIN_SHAPE_H
    if([pathPoints count] > 0)
    {
        
        b2Vec2 * verts = new b2Vec2 [(int)[pathPoints count]];
        
        int i = 0;
        for(NSValue* val in pathPoints)
        {
            CGPoint pt = LHPointFromValue(val);
            verts [i]. x = pt.x / ptm;
            verts [i]. y = pt.y / ptm;
            ++i;
        }
        
        b2ChainShape shape;
        shape.CreateChain (verts, (int)[pathPoints count]);
        
        b2FixtureDef fixture;
        
        
        fixture.density = [dictionary floatForKey:@"Density"];
        fixture.friction = [dictionary floatForKey:@"Friction"];
        fixture.restitution = [dictionary floatForKey:@"Restitution"];
        
        fixture.filter.categoryBits = (uint16)[dictionary intForKey:@"Category"];
        fixture.filter.maskBits = (uint16)[dictionary intForKey:@"Mask"];
        fixture.filter.groupIndex = (int16)[dictionary intForKey:@"Group"];
        
        fixture.isSensor = [dictionary boolForKey:@"IsSensor"];
        
        fixture.shape = &shape;
        body-> CreateFixture (& fixture);
        delete [] verts;
    }
    
#else //old box2d library
    
    if([pathPoints count] > 0)
    {
        float density = [dictionary floatForKey:@"Density"];
        float friction = [dictionary floatForKey:@"Friction"];
        float restitution = [dictionary floatForKey:@"Restitution"];
        
        int categoryBits= [dictionary intForKey:@"Category"];
        int maskBits = [dictionary intForKey:@"Mask"];
        int group = [dictionary intForKey:@"Group"];
        
        int isSensor = [dictionary boolForKey:@"IsSensor"];
        
        CGPoint firstPt;
        int j = 0;
        for(int i = 0; i < [pathPoints count]; ++i)
        {
            if(j < [pathPoints count])
            {
                NSValue* val1 = [pathPoints objectAtIndex:j + 0];
                CGPoint pt1 = LHPointFromValue(val1);
                
                if(j == 0)
                    firstPt = pt1;
                
                CGPoint pt2 = firstPt;
                
                if(j+1 < [pathPoints count])
                {
                    NSValue* val2 = [pathPoints objectAtIndex:j+1];
                    pt2 = LHPointFromValue(val2);
                }
                
                j+=2;
                
                b2Vec2 *verts = new b2Vec2[2];
                b2PolygonShape shape;
                
                verts [0]. x = pt1.x / ptm;
                verts [0]. y = pt1.y / ptm;
                
                verts [1]. x = pt2.x / ptm;
                verts [1]. y = pt2.y / ptm;
                
                shape.Set(verts, 2);
                b2FixtureDef fixture;
                
                fixture.density = density;
                fixture.friction = friction;
                fixture.restitution = restitution;
                
                fixture.filter.categoryBits = categoryBits;
                fixture.filter.maskBits = maskBits;
                fixture.filter.groupIndex = group;
                
                fixture.isSensor = isSensor;
                
                fixture.shape = &shape;
                body->CreateFixture(&fixture);
                
                delete [] verts;
            }
        }
    }
    
#endif
    
}
#endif

-(void) loadUserCustomInfoFromDictionary:(NSDictionary*)dictionary{
    userCustomInfo = nil;
    if(!dictionary)return;
    
    NSString* className = [dictionary stringForKey:@"ClassName"];
    Class customClass = NSClassFromString(className);
    
    if(!customClass) return;
    
    userCustomInfo = [customClass performSelector:@selector(customClassInstance)];
#ifndef LH_ARC_ENABLED
    [userCustomInfo retain];
#endif
    [userCustomInfo performSelector:@selector(setPropertiesFromDictionary:)
                         withObject:[dictionary objectForKey:@"ClassRepresentation"]];
}
-(NSString*)userInfoClassName{
    if(userCustomInfo)
        return NSStringFromClass([userCustomInfo class]);
    return @"No Class";
}
//------------------------------------------------------------------------------

////////////////////////////////////////////////////////////////////////////////
-(id) initWithDictionary:(NSDictionary*)dictionary
{
	self = [super init];
	if (self != nil)
	{
        uniqueName = [[NSString alloc] initWithString:[dictionary stringForKey:@"UniqueName"]];
        NSDictionary* textureDict = [dictionary objectForKey:@"TextureProperties"];
        
		isClosed	= [textureDict boolForKey:@"IsClosed"];
		isTile		= [textureDict boolForKey:@"IsTile"];
		isVisible	= [textureDict boolForKey:@"IsDrawable"];
		isLine		= [textureDict boolForKey:@"IsSimpleLine"];
		isPath		= [textureDict boolForKey:@"IsPath"];
        opacity     = [textureDict floatForKey:@"Opacity"];
		color       = [textureDict rectForKey:@"Color"];
		lineColor   = [textureDict rectForKey:@"LineColor"];
		lineWidth   = [textureDict floatForKey:@"LineWidth"];
        
        if([textureDict objectForKey:@"DrawBorder"])
            drawBorder  = [textureDict boolForKey:@"DrawBorder"];
        else
            drawBorder = true;
        
		[self setTag:[textureDict intForKey:@"Tag"]];
		[self setVertexZ:[textureDict intForKey:@"ZOrder"]];
        
        
#if COCOS2D_VERSION >= 0x00020000
        [self setZOrder:[textureDict intForKey:@"ZOrder"]];
        self.shaderProgram = [[CCShaderCache sharedShaderCache] programForKey:kCCShader_PositionTextureColor];
        lineShaderProgram = [[CCShaderCache sharedShaderCache] programForKey:kCCShader_PositionColor];
#else
        zOrder_ = [textureDict intForKey:@"ZOrder"]; //this property is read only on cocos2d 1.0
#endif
        
        NSString* img = [textureDict stringForKey:@"ImageFile"];
		if(![img isEqualToString:@""] && ![img isEqualToString:@"No Image"]){
            NSString* path = [[LHSettings sharedInstance] imagePath:img];
			[self setTexture:[[CCTextureCache sharedTextureCache] addImage:path]];
		}
		
        NSDictionary* physicsDict = [dictionary objectForKey:@"PhysicsProperties"];
		[self initTileAndPathVerticesFromDictionary:textureDict
                                       tileVertices:[physicsDict objectForKey:@"TileVertices"]];
        
        
#ifdef LH_USE_BOX2D
        b2World* world = [[LHSettings sharedInstance] activeBox2dWorld];
        if(NULL != world)
            [self createBodyFromDictionary:physicsDict physicWorld:world];
#endif
        
        touchBeginObserver = nil;
        touchMovedObserver = nil;
        touchEndedObserver = nil;
        
        tagTouchBeginObserver = nil;
        tagTouchMovedObserver = nil;
        tagTouchEndedObserver = nil;
        
        [self loadUserCustomInfoFromDictionary:[dictionary objectForKey:@"CustomClassInfo"]];
        
        [LevelHelperLoader setTouchDispatcherForObject:self tag:(int)self.tag];
        
        [self setAnchorPoint:ccp(0,0)];
	}
	return self;
}
////////////////////////////////////////////////////////////////////////////////
+(id) bezierWithDictionary:(NSDictionary*)properties
{
#ifndef LH_ARC_ENABLED
	return [[[self alloc] initWithDictionary:properties] autorelease];
#else
    return [[self alloc] initWithDictionary:properties];
#endif
}
////////////////////////////////////////////////////////////////////////////////
-(NSString*)uniqueName{
    return uniqueName;
}
////////////////////////////////////////////////////////////////////////////////
#ifdef LH_USE_BOX2D
-(b2Body*)body{
    return body;
}
#endif
////////////////////////////////////////////////////////////////////////////////
+(bool) isLHBezier:(id)object{
    return [object isKindOfClass:[LHBezier class]];
}
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
-(bool)isTouchedAtPoint:(CGPoint)point{
    
#ifdef LH_USE_BOX2D
    if(body != NULL)
    {
        b2Fixture* stFix = body->GetFixtureList();
        while(stFix != 0){
            if(stFix->TestPoint(b2Vec2(point.x/[[LHSettings sharedInstance] lhPtmRatio],
                                       point.y/[[LHSettings sharedInstance] lhPtmRatio]))){
                return true;
            }
            stFix = stFix->GetNext();
        }
    }
#endif
    return false;
}
//------------------------------------------------------------------------------
-(void)registerTouchBeginObserver:(id)observer selector:(SEL)selector{
    [self registerTouchBeganObserver:observer selector:selector];
}

-(void)registerTouchBeganObserver:(id)observer selector:(SEL)selector{
    
    if(!isTile){
        NSLog(@"Touch Events on bezier objects can only be performed on Tiled Shapes beziers. Touch Event Will be ignored.");
        return;
    }
    
    if(nil == touchBeginObserver)
        touchBeginObserver = [LHObserverPair observerPair];
    
    touchBeginObserver.object = observer;
    touchBeginObserver.selector = selector;
#ifndef LH_ARC_ENABLED
    [touchBeginObserver retain];
#endif
    
    [LevelHelperLoader setTouchDispatcherForObject:self tag:(int)self.tag];
}
//------------------------------------------------------------------------------
-(void)registerTouchMovedObserver:(id)observer selector:(SEL)selector{
    if(!isTile){
        NSLog(@"Touch Events on bezier objects can only be performed on Tiled Shapes beziers. Touch Event Will be ignored.");
        return;
    }
    
    if(nil == touchMovedObserver)
        touchMovedObserver = [LHObserverPair observerPair];
    
    touchMovedObserver.object = observer;
    touchMovedObserver.selector = selector;
#ifndef LH_ARC_ENABLED
    [touchMovedObserver retain];
#endif
}
//------------------------------------------------------------------------------
-(void)registerTouchEndedObserver:(id)observer selector:(SEL)selector{
    
    if(!isTile){
        NSLog(@"Touch Events on bezier objects can only be performed on Tiled Shapes beziers. Touch Event Will be ignored.");
        return;
    }
    
    if(nil == touchEndedObserver)
        touchEndedObserver = [LHObserverPair observerPair];
    
    touchEndedObserver.object = observer;
    touchEndedObserver.selector = selector;
#ifndef LH_ARC_ENABLED
    [touchEndedObserver retain];
#endif
}
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
#ifdef __MAC_OS_X_VERSION_MAX_ALLOWED
//for left mouse events use the touch observers from above
-(void)registerRightMouseDownObserver:(id)observer selector:(SEL)selector{
    if(nil == rightMouseDownObserver)
        rightMouseDownObserver = [LHObserverPair observerPair];
    
    rightMouseDownObserver.object = observer;
    rightMouseDownObserver.selector = selector;
#ifndef LH_ARC_ENABLED
    [rightMouseDownObserver retain];
#endif
}
//------------------------------------------------------------------------------
-(void)registerRightMouseDraggedObserver:(id)observer selector:(SEL)selector{
    if(nil == rightMouseDraggedObserver)
        rightMouseDraggedObserver = [LHObserverPair observerPair];
    
    rightMouseDraggedObserver.object = observer;
    rightMouseDraggedObserver.selector = selector;
#ifndef LH_ARC_ENABLED
    [rightMouseDraggedObserver retain];
#endif
}
//------------------------------------------------------------------------------
-(void)registerRightMouseUpObserver:(id)observer selector:(SEL)selector{
    if(nil == rightMouseUpObserver)
        rightMouseUpObserver = [LHObserverPair observerPair];
    
    rightMouseUpObserver.object = observer;
    rightMouseUpObserver.selector = selector;
#ifndef LH_ARC_ENABLED
    [rightMouseUpObserver retain];
#endif
}
#endif
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
#ifdef __IPHONE_OS_VERSION_MAX_ALLOWED
- (BOOL)ccTouchBegan:(UITouch *)touch withEvent:(UIEvent *)event{
    CGPoint touchPoint = [touch locationInView:[touch view]];
    touchPoint=  [[CCDirector sharedDirector] convertToGL:touchPoint];
    
    
    if([self isTouchedAtPoint:touchPoint])
    {
        LHTouchInfo* info = [LHTouchInfo touchInfo];
        info.relativePoint = CGPointMake(touchPoint.x - self.position.x,
                                         touchPoint.y - self.position.y);
        info.glPoint = touchPoint;
        info.event = event;
        info.touch = touch;
        info.bezier = self;
        info.delta = CGPointZero;
        
        [LHObserverPair performObserverPair:touchBeginObserver object:info];
        [LHObserverPair performObserverPair:tagTouchBeginObserver object:info];
        
        return swallowTouches;
    }
    return NO;
}
//------------------------------------------------------------------------------
- (void)ccTouchMoved:(UITouch *)touch withEvent:(UIEvent *)event{
    CGPoint touchPoint = [touch locationInView:[touch view]];
    touchPoint=  [[CCDirector sharedDirector] convertToGL:touchPoint];
    
    CGPoint prevLocation = [touch previousLocationInView:[touch view]];
    prevLocation = [[CCDirector sharedDirector] convertToGL:prevLocation];
    
    LHTouchInfo* info = [LHTouchInfo touchInfo];
    info.relativePoint = CGPointMake(touchPoint.x - self.position.x,
                                     touchPoint.y - self.position.y);
    info.glPoint = touchPoint;
    info.event = event;
    info.touch = touch;
    info.delta = CGPointMake(touchPoint.x - prevLocation.x,
                             touchPoint.y - prevLocation.y);
    info.bezier = self;
    
    [LHObserverPair performObserverPair:touchMovedObserver object:info];
    [LHObserverPair performObserverPair:tagTouchMovedObserver object:info];
}
//------------------------------------------------------------------------------
- (void)ccTouchEnded:(UITouch *)touch withEvent:(UIEvent *)event{
    
    CGPoint touchPoint = [touch locationInView:[touch view]];
    touchPoint=  [[CCDirector sharedDirector] convertToGL:touchPoint];
    
    CGPoint prevLocation = [touch previousLocationInView:[touch view]];
    prevLocation = [[CCDirector sharedDirector] convertToGL:prevLocation];
    
    LHTouchInfo* info = [LHTouchInfo touchInfo];
    info.relativePoint = CGPointMake(touchPoint.x - self.position.x,
                                     touchPoint.y - self.position.y);
    info.glPoint = touchPoint;
    info.event = event;
    info.touch = touch;
    info.bezier = self;
    info.delta = CGPointMake(touchPoint.x - prevLocation.x,
                             touchPoint.y - prevLocation.y);
    
    [LHObserverPair performObserverPair:touchEndedObserver object:info];
    [LHObserverPair performObserverPair:tagTouchEndedObserver object:info];
}
//------------------------------------------------------------------------------
#elif defined(__MAC_OS_X_VERSION_MAX_ALLOWED)
//------------------------------------------------------------------------------
-(BOOL) ccMouseDown:(NSEvent*)event{
    
    CGPoint touchPoint = [(CCDirectorMac*)[CCDirector sharedDirector] convertEventToGL:event];
    
    if([self isTouchedAtPoint:touchPoint])
    {
        mouseDownStarted = true;
        LHTouchInfo* info = [LHTouchInfo touchInfo];
        info.relativePoint = CGPointMake(touchPoint.x - self.position.x,
                                         touchPoint.y - self.position.y);
        info.glPoint = touchPoint;
        info.event = event;
        info.touch = nil;
        info.bezier = self;
        info.delta = CGPointZero;
        
        [LHObserverPair performObserverPair:touchBeginObserver object:info];
        [LHObserverPair performObserverPair:tagTouchBeginObserver object:info];
        
        return swallowTouches;
    }
    return NO;//propagation
}
//------------------------------------------------------------------------------
-(BOOL) ccMouseDragged:(NSEvent*)event{
    
    if(!mouseDownStarted)
        return NO;
    
    CGPoint touchPoint = [(CCDirectorMac*)[CCDirector sharedDirector] convertEventToGL:event];
    
    LHTouchInfo* info = [LHTouchInfo touchInfo];
    info.relativePoint = CGPointMake(touchPoint.x - self.position.x,
                                     touchPoint.y - self.position.y);
    info.glPoint = touchPoint;
    info.event = event;
    info.touch = nil;
    info.bezier = self;
    info.delta = CGPointMake([event deltaX], [event deltaY]);
    
    [LHObserverPair performObserverPair:touchMovedObserver object:info];
    [LHObserverPair performObserverPair:tagTouchMovedObserver object:info];
    
    return swallowTouches;//avoid propagation
}
//------------------------------------------------------------------------------
-(BOOL) ccMouseUp:(NSEvent*)event{
    
    if(!mouseDownStarted)
        return NO;
    
    CGPoint touchPoint = [(CCDirectorMac*)[CCDirector sharedDirector] convertEventToGL:event];
    
    mouseDownStarted = false;
    LHTouchInfo* info = [LHTouchInfo touchInfo];
    info.relativePoint = CGPointMake(touchPoint.x - self.position.x,
                                     touchPoint.y - self.position.y);
    info.glPoint = touchPoint;
    info.event = event;
    info.touch = nil;
    info.bezier = self;
    info.delta = CGPointMake([event deltaX], [event deltaY]);
    
    [LHObserverPair performObserverPair:touchEndedObserver object:info];
    [LHObserverPair performObserverPair:tagTouchEndedObserver object:info];
    
    return swallowTouches;//avoid propagation
}
//------------------------------------------------------------------------------
-(BOOL) ccRightMouseDown:(NSEvent*)event{
    
    CGPoint touchPoint = [(CCDirectorMac*)[CCDirector sharedDirector] convertEventToGL:event];
    
    if([self isTouchedAtPoint:touchPoint])
    {
        r_mouseDownStarted = true;
        LHTouchInfo* info = [LHTouchInfo touchInfo];
        info.relativePoint = CGPointMake(touchPoint.x - self.position.x,
                                         touchPoint.y - self.position.y);
        info.glPoint = touchPoint;
        info.event = event;
        info.touch = nil;
        info.bezier = self;
        info.delta = CGPointZero;
        
        [LHObserverPair performObserverPair:rightMouseDownObserver object:info];
        [LHObserverPair performObserverPair:tagRightMouseDownObserver object:info];
        
        return swallowTouches;
    }
    return NO;//propagation
}
//------------------------------------------------------------------------------
-(BOOL) ccRightMouseDragged:(NSEvent*)event{
    
    if(!r_mouseDownStarted)
        return NO;
    
    CGPoint touchPoint = [(CCDirectorMac*)[CCDirector sharedDirector] convertEventToGL:event];
    
    LHTouchInfo* info = [LHTouchInfo touchInfo];
    info.relativePoint = CGPointMake(touchPoint.x - self.position.x,
                                     touchPoint.y - self.position.y);
    info.glPoint = touchPoint;
    info.event = event;
    info.touch = nil;
    info.bezier = self;
    info.delta = CGPointMake([event deltaX], [event deltaY]);
    
    [LHObserverPair performObserverPair:rightMouseDraggedObserver object:info];
    [LHObserverPair performObserverPair:tagRightMouseDraggedObserver object:info];
    
    return swallowTouches;//avoid propagation
}
//------------------------------------------------------------------------------
-(BOOL) ccRightMouseUp:(NSEvent*)event{
    
    if(!r_mouseDownStarted)
        return NO;
    
    CGPoint touchPoint = [(CCDirectorMac*)[CCDirector sharedDirector] convertEventToGL:event];
    r_mouseDownStarted = false;
    LHTouchInfo* info = [LHTouchInfo touchInfo];
    info.relativePoint = CGPointMake(touchPoint.x - self.position.x,
                                     touchPoint.y - self.position.y);
    info.glPoint = touchPoint;
    info.event = event;
    info.touch = nil;
    info.bezier = self;
    info.delta = CGPointMake([event deltaX], [event deltaY]);
    
    [LHObserverPair performObserverPair:rightMouseUpObserver object:info];
    [LHObserverPair performObserverPair:tagRightMouseUpObserver object:info];
    
    return swallowTouches;//avoid propagation
}
//------------------------------------------------------------------------------
#endif //touch events on mac
//------------------------------------------------------------------------------

#ifdef LH_USE_BOX2D
+(NSString*) uniqueNameForBody:(b2Body*)body{
    
#ifndef LH_ARC_ENABLED
    id spr = (id)body->GetUserData();
#else
    id spr = (__bridge id)body->GetUserData();
#endif
    
    if([LHSprite isLHSprite:spr])
        return [spr uniqueName];
    
    if([LHBezier isLHBezier:spr])
        return [spr uniqueName];
    
    return nil;
}
//------------------------------------------------------------------------------
+(LHBezier*) bezierForBody:(b2Body*)body
{
    if(0 == body)
        return nil;
#ifndef LH_ARC_ENABLED
    id bz = (id)body->GetUserData();
#else
    id bz = (__bridge id)body->GetUserData();
#endif
    
    if([LHBezier isLHBezier:bz])
        return bz;
    
    return nil;
}
//------------------------------------------------------------------------------
+(int) tagForBody:(b2Body*)body{
    if(0 != body){
#ifndef LH_ARC_ENABLED
        CCNode* spr = (CCNode*)body->GetUserData();
#else
        CCNode* spr = (__bridge CCNode*)body->GetUserData();
#endif
        if(nil != spr){
            return (int)[spr tag];
        }
    }
    return -1;
}

-(void)setCollisionFilterCategory:(int)category{
    if(body == nil)
        return;
    
    b2Fixture* curFix = body->GetFixtureList();
    while (curFix) {
        
        b2Filter curFilter = curFix->GetFilterData();
        
        b2Filter filter;
        filter.categoryBits = (uint16)category;
        filter.maskBits     = curFilter.maskBits;
        filter.groupIndex   = curFilter.groupIndex;
        
        curFix->SetFilterData(filter);
        curFix = curFix->GetNext();
    }
}
-(void)setCollisionFilterMask:(int)mask{
    if(body == nil)
        return;
    
    b2Fixture* curFix = body->GetFixtureList();
    while (curFix) {
        
        b2Filter curFilter = curFix->GetFilterData();
        
        b2Filter filter;
        filter.categoryBits = curFilter.categoryBits;
        filter.maskBits     = (uint16)mask;
        filter.groupIndex   = curFilter.groupIndex;
        
        curFix->SetFilterData(filter);
        curFix = curFix->GetNext();
    }
}
-(void)setCollisionFilterGroup:(int)group{
    if(body == nil)
        return;
    b2Fixture* curFix = body->GetFixtureList();
    while (curFix) {
        
        b2Filter curFilter = curFix->GetFilterData();
        
        b2Filter filter;
        filter.categoryBits = curFilter.categoryBits;
        filter.maskBits     = curFilter.maskBits;
        filter.groupIndex   = (int16)group;
        
        curFix->SetFilterData(filter);
        curFix = curFix->GetNext();
    }
}

#endif
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
-(id)userInfo{
    return userCustomInfo;
}
@end
